<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><meta name="author" content="gungunba"><link rel="icon" href="/img/favicon.png"><title>Xuankang Lin</title><meta name="description" content="Personal Website of Xuankang Lin"><link rel="alternate" type="application/rss+xml" title="Xuankang Lin" href="/atom.xml"><link rel="stylesheet" href="//stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/css/highlight.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><meta name="generator" content="Hexo 5.4.0"></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class="container-fluid"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target="#main-navbar" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">Xuankang's Blog</a></div><div id="main-navbar" class="collapse navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="/About-Me/">About</a></li><li><a href="/archives">Archive</a></li></ul></div><div class="avatar-container"><div class="avatar-img-border"><a href="/"><img src="/img/avartar.jpg" class="avatar-img"></a></div></div></div></nav><header class="header-section"><div class="intro-header no-img"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><h1>Lab - Experiencing Memory Models using Herd7</h1><p class="post-meta">Posted on Dec 15, 2016</p></div></div></div></div></div></header><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role="main" class="blog-post"><p>This is the Lab preparation for explaining relaxed memory models using herd7 simulator.</p>
<span id="more"></span>

<br/>

<p>The outline for this lab is:</p>
<ol>
<li>Set up the environment;</li>
<li>Get familiar with litmus tests / memory model definitions and the herd7 tool website.</li>
<li>Define the TSO model step by step.</li>
<li>Explore some more interesting litmus tests that could exhibit different behaviors among multiple models.</li>
</ol>
<h2 id="Environment-set-up"><a href="#Environment-set-up" class="headerlink" title="Environment set-up"></a>Environment set-up</h2><p>In this lab, we will be experiencing memory models using <a target="_blank" rel="noopener" href="http://diy.inria.fr/"><em>herd7</em></a> – a memory model simulator.</p>
<h3 id="Use-website-version"><a href="#Use-website-version" class="headerlink" title="Use website version"></a>Use website version</h3><p>herd7 is accessible via this website: <a target="_blank" rel="noopener" href="http://virginia.cs.ucl.ac.uk/herd/#">http://virginia.cs.ucl.ac.uk/herd/#</a>, which entirely frees users from installing the library and remembering the command line to execute + generate graphs. It is recommended to try common litmus tests with this setting.</p>
<h3 id="Install-local-herd7-tool"><a href="#Install-local-herd7-tool" class="headerlink" title="Install local herd7 tool"></a>Install local herd7 tool</h3><p>The website version is preferrable. But if the online version is not accessible (e.g. due to suddenly large amount of traffic) or more customization is necessary, we could install herd7 on our own machines, and do the experiments offline.</p>
<p>Steps:</p>
<ol>
<li><p>Install <a target="_blank" rel="noopener" href="http://www.ocaml.org/">OCaml</a></p>
</li>
<li><p>Install <a target="_blank" rel="noopener" href="https://opam.ocaml.org/">OPAM</a>, the package manager for OCaml</p>
</li>
<li><p>Run</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">opam update</span><br><span class="line">opam install herdtools7</span><br></pre></td></tr></table></figure></li>
</ol>
<p>To see the specific execution graph generated, run commands using options with <code>-evince</code> (which requires having installed evince), such as:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">herd7 -model tso_attempt2.cat -show prop -evince  sb.litmus</span><br></pre></td></tr></table></figure>

<p>For those who got problems generating and displaying execution graphs directly, one alternative is to do in two steps:</p>
<ol>
<li><p>Generate the dot file by commands of this shape:</p>
<p> <code>herd7 -model tso.cat -show prop -o ./output SB.litmus</code></p>
<p> then it will generate a <code>SB.dot</code> file under <code>./output</code> directory.</p>
</li>
<li><p>Then generate the image from this dot file using</p>
<p> <code>dot -Tpng ./output/SB.dot -o SB.png</code></p>
</li>
</ol>
<h2 id="Warm-up"><a href="#Warm-up" class="headerlink" title="Warm up"></a>Warm up</h2><p>The herd7 tool website is easy to use:<br><img src="website_intro.png"></p>
<ul>
<li>The blue “tutorial” button is to switch different testing suites.</li>
<li>In each test suite there could be multiple models (.cat) and multiple litmus tests (.litmus).<ul>
<li>On the left panel is <em>litmus test</em>.</li>
<li>On the right panel is the memory model definition.</li>
</ul>
</li>
<li>To execute the litmus test program against the specified model, click the “Play” button.</li>
<li>The results will be shown at the bottom.<ul>
<li>The left panel is the terminal output. If there is <code>OK</code> in the output, the behavior specified by litmus test condition is observed.</li>
<li>The right panel lists all corresponding execution graphs. Memory events are inter-connected by relations. The <code>· --rf--&gt; ...</code> relation means it is reading from initial writes.</li>
</ul>
</li>
</ul>
<h3 id="Litmus-tests"><a href="#Litmus-tests" class="headerlink" title="Litmus tests"></a>Litmus tests</h3><p>The litmus test program is written in herd7’s DSL. Take the Message Passing program for example (<a href="mp.litmus">src</a>),</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LISA MP</span><br><span class="line">&#123;</span><br><span class="line">x = 0;</span><br><span class="line">y = 0;</span><br><span class="line">&#125;</span><br><span class="line"> P0       | P1        ;</span><br><span class="line"> w[] x 1  | r[] r1 y  ;</span><br><span class="line"> w[] y 1  | r[] r2 x  ;</span><br><span class="line">exists (1:r1 = 1 /\ 1:r2 = 0)</span><br></pre></td></tr></table></figure>

<p>It can be further divided into 4 sections:</p>
<ol>
<li><p>Line 1 – <code>LISA MP</code>:</p>
<ul>
<li><p><code>LISA</code> specifies what <em>architecture</em> this program is supposed to run against. <code>LISA</code> is their DSL for describing litmus test programs. There are also other options such as <code>PPC</code> (Power), <code>ARM</code>, <code>AArch64</code>, <code>X86</code>, <code>C</code>, <code>CPP</code>. All these hardware or language “architectures” are used for determining how to parse the test program.</p>
</li>
<li><p><code>MP</code> is the name for this litmus test, it is the abbreviation for “Message Passing”.</p>
</li>
</ul>
</li>
<li><p>Line 2~5 – <code>&#123; x= 0; y = 0; &#125;</code> specify the initial state.</p>
</li>
<li><p>Line 6~8 are the actual program code.</p>
<ul>
<li><p>Here it specifies two threads P0 and P1. P0 writes 1 to x and then writes 1 to y, while P1 reads from y and then reads from x. Variable y serves as a flag bit to show whether variable x is ready.</p>
</li>
<li><p>The empty [] is the syntax in LISA. It represents some <em>tags</em> attached to the instruction. This could be used to express <code>rel/acq</code> atomic actions in C++11, for example. In this test program, [] is not used.</p>
</li>
</ul>
</li>
<li><p>Line 9 – <code>exists (1:r1 = 1 /\ 1:r2 = 0)</code> is the litmus test condition to validate (or invalidate). Here it asserts that the read of y in P1 returning 1 and read of x in P1 returning 0 should be possible.</p>
</li>
</ol>
<p>PS: More details of their LISA DSL can be found in their paper <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1608.06583"><em>Syntax and analytic semantics of LISA</em></a>.</p>
<h3 id="Memory-model-definition"><a href="#Memory-model-definition" class="headerlink" title="Memory model definition"></a>Memory model definition</h3><p>In the default test suite, “tutorial.cat” model is selected.</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;I can&#x27;t dance&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;withco.cat&quot;</span></span><br></pre></td></tr></table></figure>

<p>The first line <code>&quot;I can&#39;t dance&quot;</code> is the name for this model. <code>&quot;&quot;</code> is just used to include spaces as well.</p>
<p>Here it only includes “withco.cat” in the code. Relation <code>co</code> will be defined and displayed if it exists.</p>
<p><code>co</code> is short for <em>coherence</em>. It is also called <code>ws</code> (write-serialization) or <code>mo</code> (modification-order) sometimes. <code>co</code> serializes all writes to one same location. The definition / computation of <code>co</code> is not shown here, those who are interested might check it out <a target="_blank" rel="noopener" href="https://github.com/herd/herdtools7/blob/master/herd/libdir/co.cat">here</a>.</p>
<p><strong>Quiz</strong>: In the current MP litmus test, there is no <code>co</code> relation. How would you modify the litmus test program to make <code>co</code> displayed on generated execution graphs?</p>
<p><strong>Answer</strong>: There is no <code>co</code> relation in MP litmus test, because there are no two writes to the same location. For example, one modification could be adding a 3rd thread also writing to x / y, Then there will be <code>co</code> in the graphs (<a href="mp_co.litmus">src</a>):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LISA MP</span><br><span class="line">&#123;</span><br><span class="line">x = 0;</span><br><span class="line">y = 0;</span><br><span class="line">&#125;</span><br><span class="line"> P0       | P1        | P2;</span><br><span class="line"> w[] x 1  | r[] r1 y  | w[] x 2;</span><br><span class="line"> w[] y 1  | r[] r2 x  | w[] y 3;</span><br><span class="line">exists (1:r1 = 1 /\ 1:r2 = 0)</span><br></pre></td></tr></table></figure>

<br/>

<p>In herd7, the memory models to run against are specified in “.cat” format.</p>
<p><strong>Quiz</strong>: So regarding this “tutorial.cat” model, do you think it is a strong model or a weak model? You may run through the 14 associated litmus tests to be confident on that hypothesis.</p>
<p><strong>Answer</strong>: Now that it only defines the relation but not checking anything, this is the weakest model, in the sense that all 14 litmus test queries are observed due to no constraints. Of course, <code>exists (false)</code> still won’t satisfy.</p>
<br/>

<p>So, what if we want to avoid the non-MP behavior? How shall we define the model accordingly?</p>
<p>To do that, let’s first define relation <code>fr</code> (from-read). <code>fr</code> is also named <code>read-before</code> sometimes in some other works. The intuition behind <code>fr</code> is shown below:<br><img src="fr.png"><br>This image is clipped from paper <a target="_blank" rel="noopener" href="http://dl.acm.org/citation.cfm?id=2627752"><em>Herding Cats: Modelling, Simulation, Testing, and Data Mining for Weak Memory</em></a> by authors of herd7. The basic idea is that: if a read event R reads value from a write event W0 that is before another write event W1 via <code>co</code>, then R <code>fr</code> W1.</p>
<p>The computation of <code>fr</code> is omitted here. We could include <code>cos.cat</code> (<a target="_blank" rel="noopener" href="https://github.com/herd/herdtools7/blob/master/herd/libdir/cos.cat">src code</a>) to include the computation for both <code>fr</code> and <code>co</code>:</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;I can&#x27;t dance&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;cos.cat&quot;</span></span><br></pre></td></tr></table></figure>

<p>Now run the MP litmus test again against the refined model, relation <code>fr</code> will appear in the generated execution graphs. Below is the execution graph that demonstrates <code>&#123; r1 = 1 ∧ r2 = 0 &#125;</code> non-MP behavior:</p>
<p><img src="mp-fr.svg"></p>
<p><strong>Quiz</strong>: How could we modify the model to avoid this execution, and potentially also avoids similar behaviors in the future? Hint: cycles are usually suspicious in memory model specifications.</p>
<p><strong>Answer</strong>: We can see a <code>po · rf · po · fr</code> cycle in the graph. If we forbid such cycle, this execution will be eliminated.</p>
<p>To do so, the model may be written as:</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;I can&#x27;t dance&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;cos.cat&quot;</span></span><br><span class="line"></span><br><span class="line">acyclic po | rf | fr</span><br></pre></td></tr></table></figure>

<p>Here <code>|</code> operator means union of two relations. Run the MP litmus test against this new model, you will see that this erroneous execution graph is gone. There are only 3 possible executions and no non-MP behavior is observed.</p>
<br/>

<p>The modification we just made turns it into a stronger model. In fact, Sequential Consistency, one of the strongest memory model, can be defined in a similar way: (<a target="_blank" rel="noopener" href="https://github.com/herd/herdtools7/blob/master/herd/libdir/sc.cat">src</a>)</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;fences.cat&quot;</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;cos.cat&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(* Atomic *)</span></span><br><span class="line">empty rmw &amp; (fre;coe) <span class="keyword">as</span> atom</span><br><span class="line"></span><br><span class="line"><span class="comment">(* Sequential consistency *)</span></span><br><span class="line">acyclic po | fr | rf | co <span class="keyword">as</span> sc</span><br></pre></td></tr></table></figure>

<p>Forget about the fences for the moment, SC requires in line 10 that <code>po</code> (program-order, also called <code>sequenced-before</code> in some other works), <code>fr</code> (from-read), <code>rf</code> (read-from), and <code>co</code> (coherence) unioned together should be acyclic.</p>
<p><strong>Quiz</strong>: Copy the definition for SC into the right panel on website, and try it with other litmus tests. Which litmus tests can still exhibit weak behaviors?</p>
<p><strong>Answer</strong>: You’ll find that SC is very restrictive, no weak behaviors in these litmus tests are still observable under SC.</p>
<br/>

<p>SC is intuitive to programmers, but as we will see shortly, more relaxed models are actually used in practice.</p>
<p>PS: More details of their <em>cat</em> DSL can be found in their paper <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1608.07531"><em>Syntax and semantics of the weak consistency model specification language cat</em></a>.</p>
<h2 id="Total-Store-Ordering-TSO"><a href="#Total-Store-Ordering-TSO" class="headerlink" title="Total Store Ordering (TSO)"></a>Total Store Ordering (TSO)</h2><p>Next let’s go through the process of building the model for TSO step by step following that in herd7’s <a target="_blank" rel="noopener" href="http://diy.inria.fr/doc/herd.html#sec70">official documentation</a>.</p>
<p>TSO is chosen because it is interesting enough as well as simple enough. TSO is the model underlying x86 architecture. Other model definitions such as Power / ARM / C++11 are also accessible in the website (see corresponding test suites), but they are much more complicated.</p>
<h3 id="Attempt-1"><a href="#Attempt-1" class="headerlink" title="Attempt 1"></a>Attempt 1</h3><p>Consider the following canonical example for TSO – Store Buffering litmus test (sb.litmus in the list of tutorial test suite) (<a href="sb.litmus">src</a>):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LISA SB</span><br><span class="line">&#123;</span><br><span class="line">x = 0;</span><br><span class="line">y = 0;</span><br><span class="line">&#125;</span><br><span class="line"> P0       | P1        ;</span><br><span class="line"> w[] x 1  | w[] y 1   ;</span><br><span class="line"> r[] r1 y | r[] r2 x  ;</span><br><span class="line">exists (0:r1 = 0 /\ 1:r2 = 0)</span><br></pre></td></tr></table></figure>

<p>SB litmus test says that:</p>
<ul>
<li>Initially, x and y are both 0.</li>
<li>In both thread, it first writes 1 to a variable, and reads the value of another variable.</li>
<li>Query asks if it is possible to see that the two reads both see the initial value 0.</li>
</ul>
<p>Run this litmus against the SC model we defined just now, it shows that the case in litmus query is not observable. However, this is actually observable in real x86 machines! Which means, SC model is too strong, at least for those x86 machines.</p>
<p>In an operational perspective, TSO works by maintaining a write buffer for each thread.</p>
<ul>
<li>Each thread’s Write will go into that buffer. Buffers get flushed to global memory non-deterministically.</li>
<li>When reading, each thread will first try to find the latest value in its buffer. Only when there is no such pending write in the buffer will it read from global memory.</li>
</ul>
<p>In other words, TSO allows Write-Read reordering (to different variables of course). Because in a global view, the Write does not happen until it flushes into memory. On the other hand, the thread may “read its own write early”, earlier than other threads see that.</p>
<p>Following that in official document, let’s write a first version of the TSO model (<a href="tso_attempt1.cat">src</a>):</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;A first attempt for TSO&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;cos.cat&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(* Communication relations that order events*)</span></span><br><span class="line"><span class="keyword">let</span> com-tso = rf | co | fr</span><br><span class="line"><span class="comment">(* Program order that orders events *)</span></span><br><span class="line"><span class="keyword">let</span> po-tso = po &amp; (<span class="type">W</span>*<span class="type">W</span> | <span class="type">R</span>*<span class="type">M</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">(* TSO global-happens-before *)</span></span><br><span class="line"><span class="keyword">let</span> ghb = po-tso | com-tso</span><br><span class="line">acyclic ghb <span class="keyword">as</span> tso</span><br><span class="line">show ghb</span><br></pre></td></tr></table></figure>

<p>The key change in this temporary model is <code>po-tso</code>, which preserves those W-W, R-W, R-R pairs except W-R pairs, since TSO allow W-R reordering. Now <code>po-tso</code> is used instead of <code>po</code> to check acyclicity.</p>
<p><strong>Quiz</strong>: Do you think this would change the behavior of SB litmus?</p>
<p><strong>Answer</strong>: Turns out YES! The SB weak behavior is no more observable.</p>
<h3 id="Attempt-2"><a href="#Attempt-2" class="headerlink" title="Attempt 2"></a>Attempt 2</h3><p>But this is not enough. There are some more test cases (<a href="SB+rfi-pos.litmus">src</a>) that are forbidden by the model but indeed observable in real machines.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">X86 SB+rfi-pos</span><br><span class="line">Orig=Rfi PodRR Fre Rfi PodRR Fre</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> P0          | P1          ;</span><br><span class="line"> MOV [x],$1  | MOV [y],$1  ;</span><br><span class="line"> MOV EAX,[x] | MOV EAX,[y] ;</span><br><span class="line"> MOV EBX,[y] | MOV EBX,[x] ;</span><br><span class="line">exists (0:EAX=1 /\ 0:EBX=0 /\ 1:EAX=1 /\ 1:EBX=0)</span><br></pre></td></tr></table></figure>

<p>Initial values are 0 by default.</p>
<p>The rejected should-accept execution is shown below:</p>
<p><img src="SB+rfi-pos.png"></p>
<p>Apparently, the <code>rf · po · fr · rf · po · fr</code> relation cycle is recognized as <code>ghb</code> cycle and thus rejected.</p>
<p><strong>Quiz</strong>: How would you propose to eliminate this false negative case while still being general enough?</p>
<p><strong>Answer</strong>: The basic idea is to eliminate the specific relations among the cycle components. For example, it would suffice to exclude this kind of <code>Wx=1 --rf--&gt; Rx=1</code> and <code>Wy=1 --rf--&gt; Ry=1</code> relations.</p>
<br/>

<p>Therefore, we may define <code>rfi</code> (internal) and <code>rfe</code> (external) relation to specify reads from the same thread or from other threads. Then only consider <code>rfe</code> in the acyclicity check. (<a href="tso_attempt2.cat">src</a>)</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;A second attempt for TSO&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;cos.cat&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(* Communication relations that order events*)</span></span><br><span class="line"><span class="keyword">let</span> com-tso = rfe | co | fr</span><br><span class="line"><span class="comment">(* Program order that orders events *)</span></span><br><span class="line"><span class="keyword">let</span> po-tso = po &amp; (<span class="type">W</span>*<span class="type">W</span> | <span class="type">R</span>*<span class="type">M</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">(* TSP global-happens-before *)</span></span><br><span class="line"><span class="keyword">let</span> ghb = po-tso | com-tso</span><br><span class="line">acyclic ghb</span><br><span class="line">show ghb</span><br></pre></td></tr></table></figure>

<p>Notice the <code>com-tso</code> and <code>rfe</code> change in the model. <code>rfe</code> is assumed to be given just like <code>rf</code>. Run the litmus test against this new model, that real world weak behavior is now allowed.</p>
<h3 id="Attempt-3"><a href="#Attempt-3" class="headerlink" title="Attempt 3"></a>Attempt 3</h3><p>Again, the model is not completed, because the current model haven’t dealt with fences, at all. Consider the following SB litmus test augmented with MFENCEs (<a href="SB+mfences.litmus">src</a>):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">X86 SB+mfences</span><br><span class="line">&quot;MFencedWR Fre MFencedWR Fre&quot;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> P0          | P1          ;</span><br><span class="line"> MOV [x],$1  | MOV [y],$1  ;</span><br><span class="line"> MFENCE      | MFENCE      ;</span><br><span class="line"> MOV EAX,[y] | MOV EAX,[x] ;</span><br><span class="line">exists (0:EAX=0 /\ 1:EAX=0)</span><br></pre></td></tr></table></figure>

<p>Fence instructions are provided by hardware to restore orderings. According to x86 <a target="_blank" rel="noopener" href="http://x86.renejeschke.de/html/file_module_x86_id_170.html">manual</a>:</p>
<blockquote>
<p>MFENCE guarantees that every load and store instruction that precedes in program order the MFENCE instruction is globally visible before any load or store instruction that follows the MFENCE instruction is globally visible.</p>
</blockquote>
<p>Then the weak behavior of this litmus is not supposed to happen with MFENCEs inserted. But the current model definition even do not recognize and display MFENCE on the execution graph.</p>
<p>Here is how MFENCE could be defined:</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mem-<span class="keyword">to</span>-mfence = po &amp; <span class="type">M</span> * <span class="type">MFENCE</span></span><br><span class="line"><span class="keyword">let</span> mfence-<span class="keyword">to</span>-mem = po &amp; <span class="type">MFENCE</span> * <span class="type">M</span></span><br><span class="line"><span class="keyword">let</span> mfence = mem-<span class="keyword">to</span>-mfence; mfence-<span class="keyword">to</span>-mem</span><br><span class="line"><span class="keyword">let</span> po-tso = po &amp; (<span class="type">W</span>*<span class="type">W</span> | <span class="type">R</span>*<span class="type">M</span>) | mfence</span><br></pre></td></tr></table></figure>

<p>In this definition, MFENCE is not exactly an event in the execution, but is used to contribute as a part of <code>po</code> relation. Replace original <code>po-tso</code> relation with the definition above, the SB+mfences litmus test is now correctly handled. (<a href="tso_attempt3.cat">src</a>)</p>
<h3 id="Attempt-4"><a href="#Attempt-4" class="headerlink" title="Attempt 4"></a>Attempt 4</h3><p>There is one last conflicting litmus test to consider (<a href="CoRWR.litmus">src</a>):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X86 CoRWR</span><br><span class="line">&#123; &#125;</span><br><span class="line"> P0          ;</span><br><span class="line"> MOV EAX,[x] ;</span><br><span class="line"> MOV [x],$1  ;</span><br><span class="line"> MOV EBX,[x] ;</span><br><span class="line">exists (0:EAX=1 /\ 0:EBX=0)</span><br></pre></td></tr></table></figure>

<p>This CoRWR litmus test cares about single thread correctness. The query asks if it’s possible to first read the future writes, and read initial writes later on. This is not rejected by current model via the acyclic check as following diagram do not have a cycle:</p>
<p><img src="CoRWR.png"></p>
<p>However, this is not replay-able in website herd7. This weak behavior of this litmus test never shows up. This is due to the extra “uniproc” check executed by herd7 tool, which eliminates such sequential weird behaviors. And the website version of herd7 does not allow changing this setting.</p>
<p>To show this, we need to use offline version of herd7. Running commands</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">herd7 -model minimal CoRWR.litmus</span><br><span class="line">herd7 -model uniproc CoRWR.litmus</span><br></pre></td></tr></table></figure>

<p>will have different results. The minimal model will allow the weak behavior with output similar to:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Test CoRWR Allowed</span><br><span class="line">States 4</span><br><span class="line">0:EAX=0; 0:EBX=0;</span><br><span class="line">0:EAX=0; 0:EBX=1;</span><br><span class="line">0:EAX=1; 0:EBX=0;</span><br><span class="line">0:EAX=1; 0:EBX=1;</span><br><span class="line">Ok</span><br><span class="line">Witnesses</span><br><span class="line">Positive: 1 Negative: 3</span><br><span class="line">Condition exists (0:EAX=1 /\ 0:EBX=0)</span><br><span class="line">Observation CoRWR Sometimes 1 3</span><br></pre></td></tr></table></figure>

<p>while the “uniproc” model puts additional check to eliminate such weak behavior.</p>
<br/>

<p>For TSO, these “uniproc” check could be (somehow) specialized to</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">irreflexive po-loc &amp; (<span class="type">R</span>*<span class="type">W</span>); rfi <span class="keyword">as</span> uniprocRW</span><br><span class="line">irreflexive po-loc &amp; (<span class="type">W</span>*<span class="type">R</span>); fri <span class="keyword">as</span> uniprocWR</span><br></pre></td></tr></table></figure>

<p>Adding this to the current model will produce a correct model for TSO (<a href="tso_final.cat">src</a>):</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;A final attempt for TSO&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;cos.cat&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(* Uniproc check specialized for TSO *)</span></span><br><span class="line">irreflexive po-loc &amp; (<span class="type">R</span>*<span class="type">W</span>); rfi <span class="keyword">as</span> uniprocRW</span><br><span class="line">irreflexive po-loc &amp; (<span class="type">W</span>*<span class="type">R</span>); fri <span class="keyword">as</span> uniprocWR</span><br><span class="line"></span><br><span class="line"><span class="comment">(* Communication relations that order events*)</span></span><br><span class="line"><span class="keyword">let</span> com-tso = rfe | co | fr</span><br><span class="line"></span><br><span class="line"><span class="comment">(* Program order that orders events *)</span></span><br><span class="line"><span class="keyword">let</span> mem-<span class="keyword">to</span>-mfence = po &amp; <span class="type">M</span> * <span class="type">MFENCE</span></span><br><span class="line"><span class="keyword">let</span> mfence-<span class="keyword">to</span>-mem = po &amp; <span class="type">MFENCE</span> * <span class="type">M</span></span><br><span class="line"><span class="keyword">let</span> mfence = mem-<span class="keyword">to</span>-mfence; mfence-<span class="keyword">to</span>-mem</span><br><span class="line"><span class="keyword">let</span> po-tso = po &amp; (<span class="type">W</span>*<span class="type">W</span> | <span class="type">R</span>*<span class="type">M</span>) | mfence</span><br><span class="line"></span><br><span class="line"><span class="comment">(* TSP global-happens-before *)</span></span><br><span class="line"><span class="keyword">let</span> ghb = po-tso | com-tso</span><br><span class="line">show mfence,ghb</span><br><span class="line">acyclic ghb <span class="keyword">as</span> tso</span><br></pre></td></tr></table></figure>

<p>To further check this, you could write (or find) the litmus tests in <a target="_blank" rel="noopener" href="http://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf">Intel Memory Ordering White Paper</a> and run them against the defined model.</p>
<p>PS: Running the given litmus tests in Tutorial Suite against our freshly defined TSO model may not produce outputs. This is likely due to some internal conflicts between MFENCE and LISA definitions. For these non-MFENCE litmus tests, comment out the mfence related part would make it runnable again.</p>
<h2 id="Some-more-interesting-litmus-tests"><a href="#Some-more-interesting-litmus-tests" class="headerlink" title="Some more interesting litmus tests"></a>Some more interesting litmus tests</h2><p>Now we should more or less have some basic understandings of TSO. Other models presented in the webiste are generally (much) more complex than TSO. PowerPC and ARM model formulations can be found in Herding Cats test suite, while C++11 model formulation can be found in C11 test suite (there are many variants inside that suite).</p>
<p>Instead of delving into details of those models, let’s look at some more litmus tests that can exhibit differences among those models.</p>
<h3 id="IRIW"><a href="#IRIW" class="headerlink" title="IRIW"></a>IRIW</h3><p>IRIW is short for <em>Independent Reads of Independent Writes</em>. It is a very well-known litmus test, usually used to check if some specific model satisfies write atomicity or not.</p>
<p>There is IRIW litmus test just in tutorial test suite (<a href="iriw.litmus">src</a>):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LISA IRIW</span><br><span class="line">&#123;</span><br><span class="line">x = 0;</span><br><span class="line">y = 0;</span><br><span class="line">&#125;</span><br><span class="line"> P0       | P1       | P2      | P3       ;</span><br><span class="line"> w[] x 1  | r[] r1 x | w[] y 1 | r[] r3 y ;</span><br><span class="line">          | r[] r2 y |         | r[] r4 x ;</span><br><span class="line">exists (1:r1 = 1 /\ 1:r2 = 0 /\ 3:r3=1 /\ 3:r4=0)</span><br></pre></td></tr></table></figure>

<p>It basically says there are 4 threads: 2 of them writing to x and writing to y, respectively. The 3rd thread read x first and then read y, while the 4th thread read y first and then read x. The query of IRIW litmus test asks if it is possible for two reader threads to observe the 2 writes in different order?</p>
<p><strong>Quiz</strong>: What result of this litmus test on TSO would you predict? What about PowerPC and ARM machines? Hint: “kittens.cat” in Tutorial testing suite is “almost-TSO”, without the fences stuff. The model for Power and ARM could be found in Herding Cats suite. There are runnable IRIW tests for each model. Remember that IRIW test for Power and for ARM are different in syntax, it is important to select the correct pair when running (there are two versions of IRIW.litmus in the list).</p>
<p><strong>Answer</strong>: IRIW weak behavior is not observable under TSO, but is observable under both Power and ARM.</p>
<h3 id="2-2W"><a href="#2-2W" class="headerlink" title="2+2W"></a>2+2W</h3><p>In addition to IRIW, 2+2W is also an important litmus test. According to paper <a target="_blank" rel="noopener" href="http://dl.acm.org/citation.cfm?id=2693181"><em>Formal Reasoning about the C11 Weak Memory Model</em></a>, 2+2W is one of the smallest known examples to distinguish release-acquire from TSO model (<a href="2+2w.litmus">src</a>).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LISA 2+2w</span><br><span class="line">&#123;</span><br><span class="line">x = 0;</span><br><span class="line">y = 0;</span><br><span class="line">&#125;</span><br><span class="line"> P0       | P1      ;</span><br><span class="line"> w[] x 2  | w[] y 2 ;</span><br><span class="line"> w[] y 1  | w[] x 1 ;</span><br><span class="line">exists (x=2 /\ y=2)</span><br></pre></td></tr></table></figure>

<p>For TSO, the litmus test could be found in Tutorial test suite, and executed against kittens.cat (almost TSO) model.</p>
<p><strong>Quiz</strong>: What result would you predict for TSO?</p>
<p><strong>Answer</strong>: Weak behavior not observable.</p>
<br/>

<p>C11/C++11 model has a Release / Acquire fragment. Detailed explanations on the release / acquire / relaxed memory order atomic keywords could be found in the <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/atomic/memory_order">official documentation</a>.</p>
<p>However, the C11 test suite and Demo test suite’s c11.cat model on the tool website somehow do not produce outputs.. You could run on local herd7 to check the results for following two experiments.</p>
<p><strong>Quiz</strong>: For the following litmus test (<a href="2+2w_relaxed.litmus">src</a>), what do you think the result would be?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C 2+2w</span><br><span class="line">&#123; [x] = 0; [y] = 0; &#125;</span><br><span class="line"></span><br><span class="line">P0 (atomic_int* x, atomic_int* y) &#123;</span><br><span class="line">    atomic_store_explicit(x, 2, memory_order_relaxed);</span><br><span class="line">    atomic_store_explicit(y, 1, memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P1 (atomic_int* x, atomic_int* y) &#123;</span><br><span class="line">    atomic_store_explicit(y, 2, memory_order_relaxed);</span><br><span class="line">    atomic_store_explicit(x, 1, memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exists (x=2 /\ y=2)</span><br></pre></td></tr></table></figure>

<p>You could run this program against C++11 model by command like:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">herd7 -model c11_orig.cat 2+2w_relaxed.litmus</span><br></pre></td></tr></table></figure>

<p>“c11_orig.cat” model comes with herd7 tool. You could check out the <a target="_blank" rel="noopener" href="https://github.com/herd/herdtools7/blob/master/herd/libdir/c11_orig.cat">official code</a> and its <a target="_blank" rel="noopener" href="https://github.com/herd/herdtools7/blob/master/herd/libdir/c11_base.cat">dependencies</a> to see how delicate (or complex) C++11 model is defined..</p>
<p><strong>Answer</strong>: Weak behavior observable.</p>
<br/>

<p><strong>Quiz</strong>: Then what about the slightly modified version litmus (<a href="2+2w_release.litmus">src</a>) (replace “relaxed” with “release”)?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C 2+2w</span><br><span class="line">&#123; [x] = 0; [y] = 0; &#125;</span><br><span class="line"></span><br><span class="line">P0 (atomic_int* x, atomic_int* y) &#123;</span><br><span class="line">    atomic_store_explicit(x, 2, memory_order_release);</span><br><span class="line">    atomic_store_explicit(y, 1, memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P1 (atomic_int* x, atomic_int* y) &#123;</span><br><span class="line">    atomic_store_explicit(y, 2, memory_order_release);</span><br><span class="line">    atomic_store_explicit(x, 1, memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exists (x=2 /\ y=2)</span><br></pre></td></tr></table></figure>

<p><strong>Answer</strong>: Weak behavior also observable.</p>
<p>□</p>
</article><ul class="pager blog-pager"><li class="previous"><a href="/2016/12/18/Herd-Code-Learning-Extension-Implementation/" data-toggle="tooltip" data-placement="top" title="Herd7 Code Learning &amp; Extension Implementation Note">← Previous Post</a></li><li class="next"><a href="/2016/10/24/Reading-Group-Automatically-Comparing-Memory-Consistency-Models/" data-toggle="tooltip" data-placement="top" title="Reading Group - Automatically Comparing Memory Consistency Models">Next Post →</a></li></ul><div class="disqus-comments"><div class="comments"><div id="disqus_thread"></div></div></div><script>var url_parts = window.location.href.split("?");
var disqus_url = url_parts[0];
(function () {
    console.log("enter disqus");
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = "//andriylin-blog.disqus.com/embed.js";
    (document.head || d.body ).appendChild(dsq);
})();</script></div></div></div><footer><div class="container beautiful-jekyll-footer"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href="/atom.xml" title="RSS"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-rss"></i></span></a></li><li><a href="mailto:xuankang.lin@gmail.com" title="Email me"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-envelope"></i></span></a></li><li><a target="_blank" rel="noopener" href="https://www.linkedin.com/in/xuankanglin/" title="LinkedIn"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-linkedin"></i></span></a></li><li><a target="_blank" rel="noopener" href="https://github.com/XuankangLin" title="GitHub"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-github"></i></span></a></li><li><a target="_blank" rel="noopener" href="https://weibo.com/andriylin/" title="Weibo"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-weibo"></i></span></a></li><li><a target="_blank" rel="noopener" href="https://www.douban.com/people/andriylin/" title="Douban"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-douban"></i></span></a></li><li><a target="_blank" rel="noopener" href="https://www.goodreads.com/xuankanglin" title="Goodreads"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-goodreads"></i></span></a></li></ul><p class="copyright text-muted">© gungunba • 2022
</p><p class="theme-by text-muted">Theme by
<a target="_blank" rel="noopener" href="https://github.com/twoyao/beautiful-hexo">beautiful-hexo</a></p></div></div></div></footer><script src="//cdn.bootcss.com/jquery/1.11.2/jquery.min.js"></script><script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/js/main.js"></script><script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-42282594-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());

gtag('config', 'UA-42282594-1');</script></body></html>