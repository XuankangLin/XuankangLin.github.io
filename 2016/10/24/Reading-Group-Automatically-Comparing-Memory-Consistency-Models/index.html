<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="author" content="gungunba"><link rel="preconnect" href="https://cdnjs.cloudflare.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="icon" href="/img/favicon.png"><title>Xuankang Lin</title><meta name="description" content="Personal Website of Xuankang Lin"><link rel="alternate" type="application/rss+xml" title="Xuankang Lin" href="/atom.xml"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css" integrity="sha384-xOolHFLEh07PJGoPkLv1IbcEPTNtaed2xpHsD9ESMhqIYd0nLMwNLD69Npy4HI+N" crossorigin="anonymous"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/css/highlight.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic&amp;display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800&amp;display=swap"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Reading Group - Automatically Comparing Memory Consistency Models",
  "name": "Reading Group - Automatically Comparing Memory Consistency Models",
  "description": "&lt;p&gt;Here is my note for presenting this new paper &lt;a href=&quot;http://johnwickerson.github.io/papers/memalloy.pdf&quot;&gt;Automatically Comparing Memory Consistency Models&lt;/a&gt; in our weekly paper reading group on 10&amp;#x2F;21&amp;#x2F;2016. See our reading group &lt;a href=&quot;http://purduepl.github.io/reading-group.html&quot;&gt;webpage&lt;/a&gt; in 16fall.&lt;/p&gt;",
  "url": "https://xuankanglin.com/2016/10/24/Reading-Group-Automatically-Comparing-Memory-Consistency-Models/",
  "datePublished": "2016-10-24T20:19:00.000Z",
  "dateModified": "2021-08-18T21:28:11.226Z",
  "author": {
    "@type": "Person",
    "name": "gungunba"
  },
  "publisher": {
    "@type": "Organization",
    "name": "gungunba",
    "logo": {
      "@type": "ImageObject",
      "url": "https://xuankanglin.com/img/avartar.jpg"
    }
  }
}</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 8.1.0"></head><body><nav class="navbar navbar-expand-md navbar-light fixed-top navbar-custom"><div class="container-fluid"><a class="navbar-brand" href="/">Xuankang's Blog</a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="main-navbar"><ul class="navbar-nav ml-auto"><li class="nav-item"><a class="nav-link" href="/About-Me/">About</a></li><li class="nav-item"><a class="nav-link" href="/archives">Archive</a></li></ul></div><div class="avatar-container"><div class="avatar-img-border"><a href="/"><img class="avatar-img" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/img/avartar.jpg" alt="gungunba" loading="eager"></a></div></div></div></nav><header class="header-section"><div class="intro-header no-img"><div class="container"><div class="row"><div class="col-lg-8 offset-lg-2 col-md-10 offset-md-1"><div class="post-heading"><h1>Reading Group - Automatically Comparing Memory Consistency Models</h1><p class="post-meta">Posted on Oct 24, 2016</p></div></div></div></div></div></header><main class="container"><div class="row"><div class="col-lg-8 offset-lg-2 col-md-10 offset-md-1"><article class="blog-post"><p>Here is my note for presenting this new paper <a target="_blank" rel="noopener external nofollow noreferrer" href="http://johnwickerson.github.io/papers/memalloy.pdf">Automatically Comparing Memory Consistency Models</a> in our weekly paper reading group on 10&#x2F;21&#x2F;2016. See our reading group <a target="_blank" rel="noopener external nofollow noreferrer" href="http://purduepl.github.io/reading-group.html">webpage</a> in 16fall.</p>
<span id="more"></span>

<br/>

<p>Please do not hesitate to correct me if I am wrong anywhere. Thanks in advance. üôÇ</p>
<h2 id="Why-picked-this-paper"><a href="#Why-picked-this-paper" class="headerlink" title="Why picked this paper"></a>Why picked this paper</h2><p>This new paper will appear in the upcoming POPL‚Äô17. It‚Äôs related to what I have been thinking about for a while. As you‚Äôll see, the idea in the paper is very inspiring, I quite like this paper.</p>
<h2 id="Some-short-background"><a href="#Some-short-background" class="headerlink" title="Some (short) background"></a>Some (short) background</h2><h3 id="Memory-Consistency-Models"><a href="#Memory-Consistency-Models" class="headerlink" title="Memory Consistency Models"></a>Memory Consistency Models</h3><p>I usually use a shorter term ‚ÄúMemory Models‚Äù for them. They essentially define what values can be returned for a READ in different scenarios, mostly in a concurrent setting.</p>
<h3 id="Litmus-Tests"><a href="#Litmus-Tests" class="headerlink" title="Litmus Tests"></a>Litmus Tests</h3><p>Litmus tests are essentially some tiny concurrent program snippets with a final assertion specifying which is the expected behavior. For example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Initially:</span><br><span class="line">  x = y = r1 = r2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">T1:          T2:</span><br><span class="line">  x := <span class="number">1</span>  ||   y := <span class="number">1</span></span><br><span class="line">  r1 := y ||   y2 := x</span><br><span class="line"></span><br><span class="line">Condition: ‚àÉ state . r1 = r2 = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>Generally it is enough for the final condition to refer to a specific state instead of some abstract assertions. There might be more abstract expressive litmus tests, but at least this paper only takes this form, for the purpose of their Execution‚ÜíLitmusTest synthesis.</p>
<h2 id="What-they-have-done"><a href="#What-they-have-done" class="headerlink" title="What they have done"></a>What they have done</h2><h3 id="4-in-1-problem-formulation"><a href="#4-in-1-problem-formulation" class="headerlink" title="4-in-1 problem formulation"></a>4-in-1 problem formulation</h3><p>First of all, the authors re-formulated 4 kinds of problems into one general problem:</p>
<ol>
<li>About generating litmus tests for one model.</li>
<li>About comparing different models.</li>
<li>About verified optimization or fence insertion ‚Äì can strengthening a program ever introduce additional behaviors?<ul>
<li>Such strengthening (refinement) is supposed to reduce behaviors just like ‚Äúoptimization‚Äù, isn‚Äôt it. No unprecedented behavior is expected.</li>
</ul>
</li>
<li>About verified compilation on RMM.<ul>
<li>Again, it‚Äôs introducing new behaviors during compilation, some behaviors that are disallowed in the source model, but permitted in the target model.</li>
</ul>
</li>
</ol>
<p>They formulate the new general problem as: <code>g(M, N, ‚ñ≤)</code>.</p>
<p>It basically says to find some litmus tests <code>(P, œÉ)</code> and <code>(Q, œÉ)</code>. Here <code>(P, œÉ)</code> is some litmus test with P being the program and œÉ being the final state to check observability. They should satisfy following properties.</p>
<ol>
<li><code>M |‚â† (P, œÉ)</code>, the litmus test <code>(P, œÉ)</code> does not conform to M.</li>
<li><code>N ‚ä® (Q, œÉ)</code>, the litmus test <code>(Q, œÉ)</code> conforms to N.</li>
<li><code>P ‚ñ≤ Q</code>, two litmus test programs are connected in some relation ‚ñ≤.</li>
</ol>
<p>&#x2F;&#x2F; In the paper, the ‚ñ≤ is actually some black triangle pointing to the right. But I didn‚Äôt know how to type that.. so I just picked a similar symbol ‚ñ≤.</p>
<p>Then the 4 kinds of problems are instantiations of this general problem.</p>
<ol>
<li><p>About generating litmus tests for one model</p>
<ul>
<li><code>g(M, ‚ä§, id)</code>, where ‚ä§ allows all executions and id is identity relation.</li>
<li>i.e., Find those litmus tests that do not conform to M.</li>
</ul>
</li>
<li><p>About comparing different models.</p>
<ul>
<li><code>g(M, N, id)</code>.</li>
<li>i.e., Find those litmus tests that don‚Äôt conform to M but conform to N.</li>
</ul>
</li>
<li><p>About verified optimization or fence insertion ‚Äì can strengthening a program ever introduce additional behaviors?</p>
<ul>
<li><code>g(M, M, &#39;is weaker than&#39;)</code>.</li>
<li>i.e., Find some programs that cannot reach some final state in M, but can do so after some strengthening.</li>
</ul>
</li>
<li><p>About verified compilation on RMM.</p>
<ul>
<li><code>g(M, N, &#39;compiles to&#39;)</code>.</li>
<li>i.e., Find some programs that cannot reach some final state in M, but its compiled program can do so on the real architecture N.</li>
</ul>
</li>
</ol>
<p>In their problem definition, to actually reason about the given two models, the definitions about M, N, and the relation ‚ñ≤ must also be defined (e.g. in Fig. 11), in a way that is based on their Event &#x2F; Execution hierarchy, a way that can easily encode and delegate to SAT solvers. We will see.</p>
<h3 id="Solving-the-g-M-N-‚ñ≤-problem"><a href="#Solving-the-g-M-N-‚ñ≤-problem" class="headerlink" title="Solving the g(M, N, ‚ñ≤) problem."></a>Solving the <code>g(M, N, ‚ñ≤)</code> problem.</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">M   ~~~~~  N</span><br><span class="line">‚Üì          ‚Üì</span><br><span class="line">P,œÉ ~~~~~ Q,œÉ</span><br><span class="line">‚Üì‚Üë         ‚Üì‚Üë</span><br><span class="line">X   ~~~~~  Y</span><br></pre></td></tr></table></figure>

<p>The overall workflow, in my comprehension, can be illustrated as above.</p>
<ol>
<li>In order to reason about models M &#x2F; N, try to find some witness litmus tests <code>(P, œÉ)</code> and <code>(Q, œÉ)</code>.</li>
<li>But directly reasoning on the litmus test program level is intractable, so reduce the problem to execution level.</li>
<li>First find some concrete satisfying executions X and Y.</li>
<li>Then recover the litmus tests from concrete executions X and Y.</li>
</ol>
<p>I‚Äôll explain these steps in more detail.</p>
<h4 id="Reduce-from-Litmus-Test-level-to-Execution-level"><a href="#Reduce-from-Litmus-Test-level-to-Execution-level" class="headerlink" title="Reduce from Litmus Test level to Execution level"></a>Reduce from Litmus Test level to Execution level</h4><p>Because <code>g(M, N, ‚ñ≤)</code> requires to find some <code>(P, œÉ)</code> that <em>must fail</em> on model M, it‚Äôs essentially asking to find <code>‚àÄ executions . it fails</code>. This universal quantifier <code>‚àÄ</code> turns everything intractable.</p>
<p>Their insight is to transform the litmus test level search problem into execution level search problem, and demonstrate that this becomes tractable. And reconstruct litmus test from executions later on.</p>
<p>They want to search for two executions X and Y such that:</p>
<ol>
<li>Find execution X (corresponding to P) such that <code>M |‚â† X</code></li>
<li>Find execution Y (corresponding to Q) such that <code>N ‚ä® Y</code></li>
<li>X ‚ñ≥ Y.</li>
</ol>
<p>&#x2F;&#x2F; Again, in the paper the relation ‚ñ≥ is some white triangle pointing to the right, and I don‚Äôt know how to type that..</p>
<p>Note that there is no more œÉ at the moment, the final state of found execution X will be used as œÉ. And when reconstructing litmus tests it will need both X and Y to allow the same œÉ as final condition.</p>
<p>But just these are not enough, obviously. Because this is finding just one execution X that fails on M. For the litmus test program P corresponding to X, it only means P may fail. To ensure that P <em>must fail</em>, they need to impose extra requirements ‚Äì <code>X ‚àà Dead_M</code>.</p>
<p>The definition for <code>X ‚àà Dead</code> basically says: any other execution corresponding to the same litmus test program P that is consistent with M will not reach final state. In other words, all those executions of P that reach this final state will be inconsistent with M. Hence derived ‚ÄúP must fail on M‚Äù.</p>
<p>Above is the semantics definition, the authors presented some syntactic approximation later in the paper, for real-world implementation. It‚Äôs approximation, thus loses completeness, but still preserves soundness for up to 8 events according to them.</p>
<p><em>Honestly however, I am not 100% sure why those rules would work and suffice. I‚Äôll omit that part in this note..</em></p>
<h4 id="SAT-solver-friendly"><a href="#SAT-solver-friendly" class="headerlink" title="SAT solver friendly"></a>SAT solver friendly</h4><p>They utilize SAT solvers for executions search. In my opinion, their framework for encoding is also worthy of mentioning.</p>
<p>Executions, which I call execution traces sometimes or execution graphs, the latter one may be more accurate, are defined on top of Events, as usual.</p>
<p>However, their events are some objects purely with an ID tag. You know they were usually defined to contain at least the following information altogether:</p>
<ol>
<li>which Thread</li>
<li>action type: Read&#x2F;Write&#x2F;Fence&#x2F;Lock&#x2F;Unlock&#x2F;etc.</li>
<li>address</li>
<li>value</li>
<li>ID</li>
<li>‚Ä¶</li>
</ol>
<p>But now in this paper, all those attached properties are represented as some set property. For example, <code>E ‚àà ReadSet</code> means E is a Read event.</p>
<p>There are several advantages, according to the authors. The most important reason in my opinion is that:</p>
<ol>
<li>The goal is to enable comparing different models. Different models could have different underlying event structures, by hardcoding them in some struct it‚Äôs hard to compare while by encoding as some set property it becomes easier, easier for SAT solvers.</li>
</ol>
<p>So,</p>
<ul>
<li>Events are defined upon set properties.</li>
<li>Executions are defined based on Events.</li>
<li>Memory model axioms are defined upon Executions &amp; Events.</li>
</ul>
<p>Essentially, everything is now friendly with set manipulation, therefore friendly with SAT solvers.</p>
<h4 id="Recover-Litmus-Tests-from-Executions"><a href="#Recover-Litmus-Tests-from-Executions" class="headerlink" title="Recover Litmus Tests from Executions"></a>Recover Litmus Tests from Executions</h4><p>They first define a tiny DSL for litmus test programs. For the sake of simplicity, they also define some well-formedness property, e.g., different values for different WRITEs.</p>
<p>Then the next (final) step is to recover litmus tests from the found executions. There is one inference rule in the paper (Œæ3.2):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(X, Y) ‚àà g&#x27;(M, N, ‚ñ≥)</span><br><span class="line">(P, œÉ) ‚àà litmin(X)</span><br><span class="line">(Q, œÉ) ‚àà lit(Y)</span><br><span class="line">P ‚ñ≤ Q</span><br><span class="line">----------------------</span><br><span class="line">(P, Q, œÉ) ‚àà g(M, N, ‚ñ≤)</span><br></pre></td></tr></table></figure>

<p>So the goal is to find some P &#x2F; Q &#x2F; œÉ such that:</p>
<ol>
<li><code>(P, œÉ) ‚àà litmin(X)</code></li>
<li><code>(Q, œÉ) ‚àà lit(Y)</code></li>
<li><code>P ‚ñ≤ Q</code></li>
</ol>
<p>Their approach is to define some more abstract semantic predicate<br><code>lit&#39;(X, P, œÉ, disabled, failures)</code>. This is to connect the execution and the litmus test, semantically.</p>
<ul>
<li>X and <code>(P, œÉ)</code> are the input and output, respectively.</li>
<li>‚Äúdisabled‚Äù refers to those in P‚Äôs branching statements that are not executed because condition test leads to the other way.</li>
<li>‚Äúfailures‚Äù refers to those in P‚Äôs CAS instructions that are executed after CAS-failed.</li>
</ul>
<p><code>lit&#39;()</code> holds whenever there is a bijection Œº between P and X, essentially, the instructions in P and events in X are all matched, one by one.</p>
<p>Then <code>litmin()</code> and <code>lit()</code> are defined on top of <code>lit&#39;()</code>.</p>
<ul>
<li><code>lit()</code> is some instantiation of any disabled and failures.</li>
<li><code>litmin()</code> is some instantiation of disabled and failures being ‚àÖ.</li>
</ul>
<p><code>litmin()</code> is used here for generation of P, while <code>lit()</code> is used for Q. I am not 100% certain about the reason of using a minimal for P, but I guess it‚Äôs due to the <code>P ‚ñ≤ Q</code> requirement later on. Having weaker constraints may allow more space in searching of satisfying Q.</p>
<p>As mentioned before, there is one last step, to ensure that X is the dead execution in the corresponding P. But that is not very clear to me yet, so I‚Äôd suggest you to read the original paper yourselves. They were able to check that the syntactic approximation ‚äÜ semantic deadness, for all executions with no more than 8 events.</p>
<h2 id="Else"><a href="#Else" class="headerlink" title="Else"></a>Else</h2><p>Their feasibility demonstration examples are very impressive and convincing, they manage to replay many existing problem instances and discover new instances. Their tool can generate simpler litmus tests. I‚Äôll omit all those for simplicity here.</p>
<p>‚ñ°</p>
</article><nav aria-label="Post navigation"><ul class="pagination justify-content-between"><li class="page-item"><a class="page-link" href="/2016/12/15/Herd-Lab/" data-toggle="tooltip" data-placement="top" title="Lab - Experiencing Memory Models using Herd7">‚Üê Previous Post</a></li><li class="page-item"><a class="page-link" href="/2016/09/29/%E4%BD%A0%E4%B8%80%E5%AE%9A%E7%88%B1%E8%AF%BB%E7%9A%84%E6%9E%81%E7%AE%80%E6%AC%A7%E6%B4%B2%E5%8F%B2/" data-toggle="tooltip" data-placement="top" title="‰Ω†‰∏ÄÂÆöÁà±ËØªÁöÑÊûÅÁÆÄÊ¨ßÊ¥≤Âè≤">Next Post ‚Üí</a></li></ul></nav><div class="disqus-comments"><div class="comments"><div id="disqus_thread"></div></div></div><script>var url_parts = window.location.href.split("?");
var disqus_url = url_parts[0];
(function () {
    console.log("enter disqus");
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = "//andriylin-blog.disqus.com/embed.js";
    (document.head || document.body).appendChild(dsq);
})();</script></div></div></main><footer><div class="container beautiful-jekyll-footer"><div class="row"><div class="col-lg-8 offset-lg-2 col-md-10 offset-md-1"><ul class="list-inline text-center footer-links"><li class="list-inline-item"><a href="/atom.xml" title="RSS" target="_blank" rel="noopener noreferrer" aria-label="RSS"><span class="fa-stack fa-lg" aria-hidden="true"><i class="fa-solid fa-circle fa-stack-2x"></i><i class="fa-stack-1x fa-inverse fa-solid fa-rss"></i></span></a></li><li class="list-inline-item"><a href="mailto:xuankang.lin@gmail.com" title="Email me" target="_blank" rel="noopener noreferrer" aria-label="Email me"><span class="fa-stack fa-lg" aria-hidden="true"><i class="fa-solid fa-circle fa-stack-2x"></i><i class="fa-stack-1x fa-inverse fa-solid fa-envelope"></i></span></a></li><li class="list-inline-item"><a href="https://www.linkedin.com/in/xuankanglin/" title="LinkedIn" target="_blank" rel="noopener noreferrer" aria-label="LinkedIn"><span class="fa-stack fa-lg" aria-hidden="true"><i class="fa-solid fa-circle fa-stack-2x"></i><i class="fa-stack-1x fa-inverse fa-brands fa-linkedin"></i></span></a></li><li class="list-inline-item"><a href="https://github.com/XuankangLin" title="GitHub" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><span class="fa-stack fa-lg" aria-hidden="true"><i class="fa-solid fa-circle fa-stack-2x"></i><i class="fa-stack-1x fa-inverse fa-brands fa-github"></i></span></a></li><li class="list-inline-item"><a href="https://www.douban.com/people/andriylin/" title="Douban" target="_blank" rel="noopener noreferrer" aria-label="Douban"><span class="fa-stack fa-lg" aria-hidden="true"><i class="fa-solid fa-circle fa-stack-2x"></i><img class="fa-stack-1x footer-icon-image" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/img/icons/douban.svg" alt="Douban"></span></a></li><li class="list-inline-item"><a href="https://www.goodreads.com/xuankanglin" title="Goodreads" target="_blank" rel="noopener noreferrer" aria-label="Goodreads"><span class="fa-stack fa-lg" aria-hidden="true"><i class="fa-solid fa-circle fa-stack-2x"></i><i class="fa-stack-1x fa-inverse fa-brands fa-goodreads"></i></span></a></li></ul><p class="copyright text-muted">¬© gungunba ‚Ä¢ 2025
</p><p class="theme-by text-muted">Theme by
<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/XuankangLin/beautiful-hexo">beautiful-hexo</a></p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.slim.min.js" integrity="sha384-kmHvs0B+OpCW5GVHUNjv9rOmY0IvSIRcf7zGUDTDQM3JTGVaB4sIFpPkfFv5kl5e" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-Fy6S3B9q64WdZWQUiU+q4/2Lc9npb8tCaSX9FK7E8HnRr0Jz8D6OP9dO5Vg3Q9ct" crossorigin="anonymous" defer></script><script src="/js/main.js" defer></script><script>// Add lazy loading to all images in post content
document.addEventListener('DOMContentLoaded', function() {
  const contentImages = document.querySelectorAll('.blog-post img');
  contentImages.forEach(function(img) {
    if (!img.hasAttribute('loading')) {
      img.setAttribute('loading', 'lazy');
    }
  });
});
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin="anonymous" referrerpolicy="no-referrer" defer></script><script>hljs.initHighlightingOnLoad();</script><script async src="https://www.googletagmanager.com/gtag/js?id=#{theme.google_analytics.id}"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());

gtag('config', 'G-C80PC1R3E8');</script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>