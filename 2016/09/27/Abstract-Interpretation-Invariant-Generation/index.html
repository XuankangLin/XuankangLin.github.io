<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><meta name="author" content="gungunba"><link rel="icon" href="/img/favicon.png"><title>Xuankang Lin</title><meta name="description" content="Personal Website of Xuankang Lin"><link rel="alternate" type="application/rss+xml" title="Xuankang Lin" href="/atom.xml"><link rel="stylesheet" href="//stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/css/highlight.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><meta name="generator" content="Hexo 5.4.0"></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class="container-fluid"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target="#main-navbar" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">Xuankang's Blog</a></div><div id="main-navbar" class="collapse navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="/About-Me/">About</a></li><li><a href="/archives">Archive</a></li></ul></div><div class="avatar-container"><div class="avatar-img-border"><a href="/"><img src="/img/avartar.jpg" class="avatar-img"></a></div></div></div></nav><header class="header-section"><div class="intro-header no-img"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><h1>Abstract Interpretation, Invariant Generation</h1><p class="post-meta">Posted on Sep 27, 2016</p></div></div></div></div></div></header><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role="main" class="blog-post"><p>This is my note for presentation in <a target="_blank" rel="noopener" href="https://www.cs.purdue.edu/homes/roopsha/capr.f16.html">CS590 Computer-Aided Program Reasoning</a> seminar on 09/27/2016. We are reading <a target="_blank" rel="noopener" href="http://link.springer.com/chapter/10.1007/978-3-540-74113-8_12">Œæ12</a> of book <em>The Calculus of Computation: Decision Procedures with Applications to Verification</em> to elaborate the intuition and formalization of abstract interpretation, and how that can be used for invariant generation. This seems a relatively easy reading, the chapter is well written.</p>
<p>Please do not hesitate to correct me if I am wrong anywhere. üòÅ</p>
<span id="more"></span>

<br/>

<p>Since this is a book chapter, the materials are already well-written, it is easy to find the overall clue throughout underlying texts.</p>
<ul>
<li>What‚Äôs the ultimate goal?<ul>
<li>Generate invariants, i.e. assertions that summarize the conditions that must hold at this program point on all paths.</li>
</ul>
</li>
<li>A naive approach.<ul>
<li>Predicate transformers on concrete states.</li>
<li>But may not terminate.</li>
</ul>
</li>
<li>An improved approach.<ul>
<li>Abstract Interpretation, intuitionally.</li>
<li>Illustrated using interval analysis and Karr‚Äôs analysis examples.</li>
</ul>
</li>
<li>A formalized approach.<ul>
<li>Abstract Interpretation, defined with lattice.</li>
</ul>
</li>
</ul>
<h2 id="Naive-approach"><a href="#Naive-approach" class="headerlink" title="Naive approach"></a>Naive approach</h2><p>Intuitively, the ‚Äúinvariant‚Äù can be generated by ‚à® assertions in all paths. This is why they call it <em>inductive assertions of programs</em> in the chapter.</p>
<p>Therefore, the question now becomes ‚Äúhow to generate assertion at this program point in different paths‚Äù. The answer is straightforward, just propagate by predicate transformers.</p>
<p>We have introduced in detail the <em>weakest precondition</em> (wp) in previous lectures. The <em>strongest postcondition</em> (sp) was paid less attention to at that moment, but is now heavily used in this chapter.</p>
<h3 id="Strongest-Postcondition"><a href="#Strongest-Postcondition" class="headerlink" title="Strongest Postcondition"></a>Strongest Postcondition</h3><p>As the name suggests, predicate transformer strongest postcondition is generating the strongest result after some command, in the sense that <code>‚àÄ Q . &#123;P&#125; c &#123;Q&#125;</code>, we have <code>sp(P, c) ‚áí Q</code>.</p>
<p>From my understanding, <em>Symbolic Execution</em> is basically doing strongest postcondition propagation under the hood.</p>
<p>There are some interesting rules for sp, it‚Äôs interesting to compare them with its wp duals:</p>
<ul>
<li><p>for assume:</p>
<ul>
<li><code>sp(F, assume p) ‚áî p ‚àß F</code></li>
<li><code>wp(F, assume p) ‚áî p ‚áí F</code></li>
</ul>
</li>
<li><p>for assignment:</p>
<ul>
<li><code>sp(F[v], v := e[v]) ‚áî ‚àÉ v0 . v = e[v0] ‚àß F[v0]</code></li>
<li><code>wp(F[v], v := e) ‚áî F[e]</code></li>
</ul>
</li>
</ul>
<p>For sp, it‚Äôs basically differentiating two versions of variable <code>v</code>, with <code>v0</code> being the old value. The notation here that changes <code>F[v]</code> to <code>F[v0]</code> means replacing the parts of <code>v</code> in the formula with <code>v0</code> and keep everything else unchanged.</p>
<p>Due to this extra <code>‚àÉ</code> quantifier in sp, wp is generally preferred when possible.</p>
<h3 id="Forward-Propagation-Algorithm"><a href="#Forward-Propagation-Algorithm" class="headerlink" title="Forward Propagation Algorithm"></a>Forward Propagation Algorithm</h3><p>As mentioned, the goal in chapter is to do <em>invariant generation</em>.</p>
<p>They call some program points that should assign assertions <em>cutpoints</em>, from one cutpoint to another cutpoint constructs a <em>basic path</em> (which is a segment in my dictionary).</p>
<p>My understanding for the defined <em>cutpoint</em> is just the program points that shall be assigned assertions to. One could have different set of cutpoints for different purposes. The <em>assertion map</em> just assigns assertions to each of these program points / cutpoints. The goal ‚Äì <em>invariant generation</em> ‚Äì is to find such assertion map. Note that it is not the assertion that holds throughout entire program, just at that program point.</p>
<p>To propagate assertions to each program point (cutpoint), the algorithm is:</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">ForwardPropagate</span> <span class="type">F_pre</span> <span class="type">L</span> =</span><br><span class="line">    <span class="type">S</span> := &#123;<span class="type">L0</span>&#125;;</span><br><span class="line">    Œº(<span class="type">L0</span>) := <span class="type">Fpre</span>;</span><br><span class="line">    Œº(<span class="type">L</span>) := ‚ä• <span class="keyword">for</span> <span class="type">L</span> ‚àà <span class="type">L</span> \ &#123;<span class="type">L0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> <span class="type">S</span> ‚â† ‚àÖ <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">let</span> <span class="type">Lj</span> = choose <span class="type">S</span> <span class="keyword">in</span></span><br><span class="line">        <span class="type">S</span> := <span class="type">S</span> \ &#123;<span class="type">Lj</span>&#125;;</span><br><span class="line">        foreach <span class="type">Lk</span> ‚àà succ(<span class="type">Lj</span>) <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">let</span> <span class="type">F</span> = sp(Œº(<span class="type">Lj</span>), <span class="type">Sj</span>;...;<span class="type">Sk</span>) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="type">F</span> ‚â†&gt; Œº(<span class="type">Lk</span>)</span><br><span class="line">            <span class="keyword">then</span></span><br><span class="line">              Œº(<span class="type">Lk</span>) := Œº(<span class="type">Lk</span>) ‚à® <span class="type">F</span>;</span><br><span class="line">              <span class="type">S</span> := <span class="type">S</span> ‚à™ &#123;<span class="type">Lk</span>&#125;;</span><br><span class="line">        <span class="keyword">done</span>;</span><br><span class="line">    <span class="keyword">done</span>;</span><br><span class="line">    Œº</span><br></pre></td></tr></table></figure>

<p>The algorithm is straightforward, it just propagates using sp predicate transformer, and merge the assertions from different branches/paths if necessary. The whole algorithm terminates when all assertions become stable.</p>
<h3 id="Problem-of-Naive-approach"><a href="#Problem-of-Naive-approach" class="headerlink" title="Problem of Naive approach"></a>Problem of Naive approach</h3><p>However, there is no guarantee that the algorithm will terminate, possibly due to undecidability of <code>F ‚â†&gt; Œº(Lk)</code>, possibly because always including some exact states via ‚à® may never reach to an end. Consider the following counter-example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L0: &#123; Initially: n ‚â• 0 &#125;</span><br><span class="line"></span><br><span class="line">i := 0</span><br><span class="line">L1: while (i &lt; n) &#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So:</p>
<ul>
<li><p>From L0 to L1, the assertion is <code>&#123;i = 0 ‚àß n ‚â• 0&#125;</code>.</p>
</li>
<li><p>But from L1 to L1 after one loop iteration, the new formula is added by <code>&#123;i = 1 ‚àß n &gt; 0&#125;</code>.</p>
</li>
<li><p>This could go on and on forever, because the terminating condition is never reached ‚Äì <code>Fk ‚áí F_&#123;k-1&#125;</code>, it always fails the check that the newly generated condition <code>i = k ‚àß n ‚â• k</code> ‚áí <code>(i = 0 ‚àß n ‚â• 0) ‚à® (i = 1 ‚àß n ‚â• 1) ‚à® ... ‚à® (i = k-1 ‚àß n ‚â• k-1)</code>, the collected assertion. (Page 320)</p>
<p>  This is because that we are doing some semantic analysis, and the algorithm can only check the next syntactic possible stop, thus L1 itself should always be considered as a next step for L1.</p>
</li>
</ul>
<h2 id="Improved-approach-Abstract-Interpretation"><a href="#Improved-approach-Abstract-Interpretation" class="headerlink" title="Improved approach - Abstract Interpretation"></a>Improved approach - Abstract Interpretation</h2><p>It‚Äôs obvious that there is a much simpler invariant for the above example: <code>0 ‚â§ i ‚â§ n</code>.</p>
<p>Now by the improved approach ‚Äì abstract interpretation ‚Äì it can over-approximate the concrete states, operate on abstract states, and guarantee termination via some widening heuristic if necessary.</p>
<p>Intuitively,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Abstract    ‚Üísp‚Üí     Abstract        ...... ‚Üísp‚Üí Abstract</span><br><span class="line">   ‚ÜëvD               ‚ÜóvD   ‚ÜñvD                     ‚ÜëvD</span><br><span class="line">Concrete ‚Üísp‚Üí Concrete ‚Üísp‚Üí Concrete ...... ‚Üísp‚Üí Concrete</span><br></pre></td></tr></table></figure>

<p>Below are the necessary preparation steps for abstract interpretation, throughout which the basic idea is to do the same set of operations on abstract states.</p>
<ol>
<li><p>What the abstract domain is, apparently. It stipulates the form of formulas that could appear in abstract domains.</p>
</li>
<li><p>The mapping relation from concrete states to abstract states, $v_D$. This is an over-approximation, meaning that $F ‚áí v_D(F)$.</p>
</li>
<li><p>The sp transformer was on concrete states, now there should be some sp for abstract states.</p>
<p> The new $\bar{sp}$ may need basic logic operators, hence we still need to define abstract conjunction and abstract disjunction. The basic rules are:</p>
<ol>
<li><p>The resulting formula should reside in abstract domain as well, obviously.</p>
</li>
<li><p>The resulting formula should still be an over-approximation, i.e. $F_1 ‚óã F_2 ‚áí F_1 \bar{‚óã} F_2$, where $\bar{‚óã}$ is the corresponding operator in abstract domain.</p>
</li>
</ol>
</li>
<li><p>In particular, abstract disjunction <code>‚äî</code> is emphasized, because it will be used in the same propagation algorithm operating on abstract states.</p>
</li>
<li><p>Abstract implication also needs to be specified. Because it will be used in the abstract domain version algorithm to decide whether it has reached fixpoint. For concrete states, it may even be undecidable.. But by carefully selecting the abstract domain, the implication validity check can become decidable and fast.</p>
</li>
<li><p>The last is yet another novelty ‚Äì heuristics to ensure algorithm termination, namely, a <em>widening</em> procedure. Intuitively, this is delicately defined to stretch to the limit of over-approximation.</p>
<p> Formally, let F1, F2, ‚Ä¶ be an infinite sequence of <code>Fi ‚àà D</code> such that $Fi ‚áí F_{i+1}$. Then another sequence Gi can be defined as: <code>G1 = F1</code>, <code>G&#123;i+1&#125; = Gi ‚ñΩD F&#123;i+1&#125;</code>.</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F1 ‚Üí F2 ‚Üí F3 ‚Üí ... ‚Üí Fi ‚Üí ...</span><br><span class="line"> =   ‚ñΩD   ‚ñΩD         ‚ñΩD</span><br><span class="line">G1 ‚Üí G2 ‚Üí G3 ‚Üí ... ‚Üí Gi ‚Üí ...</span><br></pre></td></tr></table></figure>

<p> Then it shall have the property that after some i, <code>Gi ‚áî Gi+1</code>. Sequence Gi converges even if Fi doesn‚Äôt converge.</p>
</li>
</ol>
<p>With all these preparation, the abstract version of forward propagation algorithm is:</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">AbstractForwardPropagate</span> <span class="type">Fpre</span> <span class="type">L</span> =</span><br><span class="line">    <span class="type">S</span> := &#123;<span class="type">L0</span>&#125;;</span><br><span class="line">    Œº(<span class="type">L0</span>) := ŒΩ<span class="type">D</span>(<span class="type">Fpre</span>);</span><br><span class="line">    Œº(<span class="type">L</span>) := ‚ä• <span class="keyword">for</span> <span class="type">L</span> ‚àà <span class="type">L</span> \ &#123;<span class="type">L0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> <span class="type">S</span> ‚â† ‚àÖ <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">let</span> <span class="type">Lj</span> = choose <span class="type">S</span> <span class="keyword">in</span></span><br><span class="line">        <span class="type">S</span> := <span class="type">S</span> \ &#123;<span class="type">Lj</span>&#125;;</span><br><span class="line">        foreach <span class="type">Lk</span> ‚àà succ(<span class="type">Lj</span> ) <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">let</span> <span class="type">F</span> = spD(Œº(<span class="type">Lj</span>), <span class="type">Sj</span>;...;<span class="type">Sk</span>) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="type">F</span> ‚â†&gt; Œº(<span class="type">Lk</span>)</span><br><span class="line">            <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">if</span> <span class="type">Widen</span><span class="literal">()</span></span><br><span class="line">                <span class="keyword">then</span></span><br><span class="line">                    Œº(<span class="type">Lk</span>) := Œº(<span class="type">Lk</span>) ‚ñΩ<span class="type">D</span> (Œº(<span class="type">Lk</span>) ‚äî<span class="type">D</span> <span class="type">F</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Œº(<span class="type">Lk</span>) := Œº(<span class="type">Lk</span>) ‚äî<span class="type">D</span> <span class="type">F</span>;</span><br><span class="line">                <span class="type">S</span> := <span class="type">S</span> ‚à™ &#123;<span class="type">Lk</span>&#125;;</span><br><span class="line">         <span class="keyword">done</span>;</span><br><span class="line">    <span class="keyword">done</span>;</span><br><span class="line">    Œº</span><br></pre></td></tr></table></figure>

<p>The main difference other than abstract version of operations is the <code>WIDEN()</code> function call. It determines whether widening should be applied (e.g. after specified max iterations, could be more complicated strategies).</p>
<p>This widening is to replace the original abstract disjunction of including more states.</p>
<p>Compare with <code>G&#123;i+1&#125; = Gi ‚ñΩD Fi+1</code>, here <code>Œº(Lk) := Œº(Lk) ‚ñΩD (Œº(Lk) ‚äîD F);</code> has <code>Œº(Lk)</code> as <code>G(i)</code> and <code>Œº(Lk) ‚äîD F</code> as <code>Fi+1</code>.</p>
<h3 id="Demonstration-Interval-Analysis"><a href="#Demonstration-Interval-Analysis" class="headerlink" title="Demonstration - Interval Analysis"></a>Demonstration - Interval Analysis</h3><p>Next, we use the example of Interval Analysis to demonstrate the just defined abstract interpretation approach.</p>
<p>Interval analysis, as the name suggests, extracts the bound of a variable.</p>
<h4 id="Step-1-Define-abstract-domain"><a href="#Step-1-Define-abstract-domain" class="headerlink" title="Step 1: Define abstract domain"></a>Step 1: Define abstract domain</h4><p>Abstract domain formula literals are of the shape: $v ‚â§ c$ and $c ‚â§ v$ for some constant number $c$.</p>
<p>Some simplification rules are also given:</p>
<ul>
<li>‚ä• ‚àß F ‚â° ‚ä•</li>
<li>‚ä§ ‚àß F ‚â° F</li>
<li>c1 ‚â§ v ‚àß c2 ‚â§ v ‚â° max(c1, c2) ‚â§ v</li>
<li>v ‚â§ c1 ‚àß v ‚â§ c2 ‚â° v ‚â§ min(c1, c2)</li>
<li>c1 &gt; c2 ‚áí c1 ‚â§ v ‚àß v ‚â§ c2 ‚â° ‚ä•</li>
</ul>
<p>All these should be intuitive.</p>
<p>Some computation rules are given:</p>
<ul>
<li><p>[l1, u1] + [l2, u2] = [l1+l2, u1+u2]</p>
</li>
<li><p>c = [c, c]</p>
</li>
<li><p>introduce ‚àû and -‚àû</p>
</li>
<li><p>[‚àû, -‚àû] is empty interval</p>
</li>
<li><p>[l1, u1] ‚äì [l2, u2] =</p>
<ul>
<li>[‚àû, -‚àû] if max(l1, l2) &gt; min(u1, u2)</li>
<li>[max(l1, l2), min(u1, u2)] otherwise</li>
</ul>
</li>
</ul>
<p>The following several rules are over-approximation:</p>
<ul>
<li><p>[l1, u1] ‚äî [l2, u2] = [min(l1, l2), max(u1, u2)].</p>
<ul>
<li>Note that this is a so called <em>interval hull</em>. It may include many unrelated segments in between.</li>
</ul>
</li>
<li><p>[l1, u1] ‚â§ [l2, u2] if l1 ‚â§ u2.</p>
<ul>
<li>i.e. as long as there exists any elements in two intervals that v1 ‚â§ v2.</li>
</ul>
</li>
<li><p>[l1, u1] = [l2, u2] if [l1, u1] ‚äì [l2, u2] ‚â† [‚àû, -‚àû].</p>
<ul>
<li>i.e. as long as there exists any elements in two intervals that v1 = v2.</li>
</ul>
</li>
</ul>
<h4 id="Step-2-Define-mapping-relation-v-Di"><a href="#Step-2-Define-mapping-relation-v-Di" class="headerlink" title="Step 2: Define mapping relation $v_{Di}$"></a>Step 2: Define mapping relation $v_{Di}$</h4><p>Now given some concrete state formula, $v_{DI}$ over-approximates it into a abstract domain formula.</p>
<p>For clause literals it only filters out those clauses such as:</p>
<ul>
<li>$av = b$</li>
<li>$av ‚â§ b$</li>
<li>$b ‚â§ av$</li>
</ul>
<p>and extract condition of variable $v$ in the basic abstract state formula as just defined.</p>
<p>However, this very weak filtering will lose much valuable information such as those more complicated inequality formulas, e.g. $j + 2n ‚â§ 4$.</p>
<p>That‚Äôs why a non-trivial $v_{Di}(H, G‚Äô)$ is defined, which basically uses the context information in $G‚Äô$ to simplify $H$. This can re-pick up the lost information of $j + 2n ‚â§ 4$, otherwise it just trivially distributes <code>vD</code> to each conjunctive clauses.</p>
<p>More formally, this is written as</p>
<span>$v_{Di}(F, G &and; v_{Di}(F))$</span><!-- Has MathJax -->

<p>For example,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F: i = 0 ‚àß n ‚â• 0 ‚àß j+2n ‚â§ 4</span><br><span class="line">H: j+2n ‚â§ 4</span><br><span class="line">G: j ‚â• 5</span><br></pre></td></tr></table></figure>

<p>With the extra context $G: j ‚â• 5$,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">= vDi (H, G ‚àß vDi(F))</span><br><span class="line">= vDi (j+2n‚â§4, 5‚â§j ‚àß 0‚â§i ‚àß i‚â§0 ‚àß 0‚â§n)</span><br><span class="line">= ‚ä•</span><br><span class="line"></span><br><span class="line">because</span><br><span class="line">j+2n = [5,‚àû] + 2[0,‚àû] = [5, ‚àû] !‚â§ [4,4]</span><br><span class="line">So j+2n‚â§4 = ‚ä•</span><br></pre></td></tr></table></figure>

<p>Without this context information, the interval won‚Äôt be [-‚àû, ‚àû].</p>
<p>Note that $F ‚áí v_{Di}(F)$, so if without $G$,</p>
<span>$v_{Di}(F, v_{Di}(F))$</span><!-- Has MathJax -->
<p>should be the same as $v_{Di}(F)$. It‚Äôs the added context information $G$ that makes everything more accurate.</p>
<p>This schema due to weak $v_{Di}$ is also used in subsequent abstract domain transformers $\bar{sp}$.</p>
<h4 id="Step-3-Define-abstract-domain-transformer-bar-sp"><a href="#Step-3-Define-abstract-domain-transformer-bar-sp" class="headerlink" title="Step 3: Define abstract domain transformer $\bar{sp}$"></a>Step 3: Define abstract domain transformer $\bar{sp}$</h4><p>‚äì in abstract domain for interval analysis is just ‚àß.</p>
<h5 id="assume"><a href="#assume" class="headerlink" title="assume"></a>assume</h5><p>The similar idea of ‚Äúusing more information‚Äù in last step can also be used here.</p>
<span>$$\bar{sp}_{D_i}(F, assume \ p) &DoubleLeftRightArrow; v_{D_i}(p, F) &and; F$$</span><!-- Has MathJax -->

<p>This $v_{Di}(p, F)$ is also intentionally making it more accurate here with the existing context information $F$.</p>
<p>Otherwise $v_{Di}(p)$ may directly discard those non-basic constraints.</p>
<h5 id="assignment"><a href="#assignment" class="headerlink" title="assignment"></a>assignment</h5><p>Let [l, u] be the interval evaluation of $e$ under the context of $F$, and $G$ is all the rest literals of $F$ not involving $v$, then</p>
<p>$\bar{sp}_{D_i}(F, v := e) ‚áî l ‚â§ v ‚àß v ‚â§ u ‚àß G$</p>
<p>This is straightforward.</p>
<p>When $e$ is too complicated, e.g. not a linear expression, set the interval of $v$ to ‚ä§.</p>
<h4 id="Step-4-Define-interval-disjunction-‚äî-D-i"><a href="#Step-4-Define-interval-disjunction-‚äî-D-i" class="headerlink" title="Step 4: Define interval disjunction $‚äî_{D_i}$"></a>Step 4: Define interval disjunction $‚äî_{D_i}$</h4><p>In interval analysis abstract domain, for</p>
<span>$$F: x &Element; [l_1, u_1] \\
G: x &Element; [l_2, u_2] \\
F &sqcup;_{Di} G = [l_1, u_1] &sqcup; [l_2, u_2]$$</span><!-- Has MathJax -->

<p>i.e. the interval hull. Over-approximation, again.</p>
<h4 id="Step-5-Define-interval-implication"><a href="#Step-5-Define-interval-implication" class="headerlink" title="Step 5: Define interval implication"></a>Step 5: Define interval implication</h4><p>In interval analysis abstract domain, for $F: x_i ‚àà [l_i, u_i]$, $G: x_i ‚àà [m_i, v_i]$, then $F ‚áí G$ iff $‚àÄ x_i, [l_i, u_i] ‚äÜ [m_i, v_i]$. i.e. subset.</p>
<h4 id="Step-6-Define-widening"><a href="#Step-6-Define-widening" class="headerlink" title="Step 6: Define widening"></a>Step 6: Define widening</h4><p>With all the steps above, it has simplified a lot, but still cannot guarantee termination.</p>
<p>See the example below:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@L0: i = 0 ‚àß n ‚â• 0</span><br><span class="line">while</span><br><span class="line">	@L1: ?</span><br><span class="line">	(i &lt; n) &#123;</span><br><span class="line">	i := i + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In this tiny program there are two so called ‚Äúbasic paths‚Äù (I‚Äôd prefer call them segments).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(1) before while loop</span><br><span class="line">	@L0: i = 0 ‚àß n ‚â• 0</span><br><span class="line">	@L1: ?</span><br><span class="line"></span><br><span class="line">(2) while loop iteration</span><br><span class="line">	@L1: ?</span><br><span class="line">	assume i &lt; n;</span><br><span class="line">	i := i + 1</span><br><span class="line">	@L1: ?</span><br></pre></td></tr></table></figure>

<p>And our goal is to generate the invariant @L1.</p>
<p>According to the algorithm, it will keep ‚Äúrun‚Äù the iteration and add newly generated assertion to invariant, all on abstract domain.</p>
<p>At the end of kth iteration, the newly generated formula $0 ‚â§ i ‚àß i ‚â§ k ‚àß 0 ‚â§ n$ never ‚áí the existing invariant formula $0 ‚â§ i ‚àß i ‚â§ k-1 ‚àß 0 ‚â§ n$.</p>
<p>To solve this, it needs to over-approximate even more, using the widening operator $‚ñΩ_{D_i}$.</p>
<p>For each variable v, suppose that $F$ asserts $v ‚àà [l_1, u_1]$ and $G$ asserts $v ‚àà [l_2, u_2]$.</p>
<p>Then $F ‚ñΩ_{Di} G$ asserts that $v ‚àà [l, u]$, where</p>
<ul>
<li>l = ‚àí‚àû if $l_2 &lt; l_1$, and otherwise $l = l_1$;</li>
<li>u = ‚àû if $u_2 &gt; u_1$, and otherwise $u = u_1$.</li>
</ul>
<p>According to usage, $F$ is the accumulated invariant, so the idea is that if the new invariant $G$ is still beyond the bound of $F$, $F$ chooses ‚àû/-‚àû as the new bound. Apparently, in this way $F$ will definitely reach some fixpoint, thus guarantee termination.</p>
<h3 id="Demonstration-Karr‚Äôs-Analysis"><a href="#Demonstration-Karr‚Äôs-Analysis" class="headerlink" title="Demonstration - Karr‚Äôs Analysis"></a>Demonstration - Karr‚Äôs Analysis</h3><p>Omitted due to time of preparation..</p>
<h2 id="Formalized-approach-Abstract-Interpretation-with-Lattices"><a href="#Formalized-approach-Abstract-Interpretation-with-Lattices" class="headerlink" title="Formalized approach - Abstract Interpretation with Lattices"></a>Formalized approach - Abstract Interpretation with Lattices</h2><p>All above is using some notation that is easy to understand, while in literatures, Abstract Interpretation is defined using more mathematical notations ‚Äì operations on lattices.</p>
<p>We should have seen lattices in <em>Discrete Mathematics</em>.</p>
<p>A lattice $(S, ‚äî, ‚äì)$ is a set equipped with join ‚äî and meet ‚äì operators that are commutative / associative, idempotent.</p>
<p>Knaster-Tarski Theorem.</p>
<blockquote>
<p>The fixpoints of a monotone function on a complete lattice comprise a complete lattice.</p>
</blockquote>
<p>It guarantees the existence of the least fixpoint and the greatest fixpoint of monotone function f.</p>
<p>My comprehension is that, if it terminates (has fixpoint) in abstract domain, it is also valid for the concrete domain. But by adding concrete state one by one it may never reach this fixpoint.</p>
<p>For abstract interpretation, consider the possible program states to be a lattice, then</p>
<ul>
<li>join is ‚à™</li>
<li>meet is ‚à©</li>
<li>partial order is ‚äÜ</li>
<li>the greatest element is all-states</li>
<li>the least element is empty-state</li>
</ul>
<p>This is represented by $C_p = (2^S, ‚à™, ‚à©)$. This is the concrete domain.</p>
<p>On this lattice, define $F_p(S‚Äô)$ as $S‚Äô ‚à™ P(S‚Äô)$. Here $P(S‚Äô)$ means the next reachable states from set S‚Äô.</p>
<p>Compare $F_p$ to the predicate transformer together with the inclusion phase in our algorithm.</p>
<p>Then ForwardPropagate algorithm is like starting from those states satisfying the initial assertion, and aim to include all the reachable states into the set.</p>
<p>But again, as we have shown, this may not terminate.</p>
<p>So define abstract domain $A_p = (A, ‚äî, ‚äì)$ corresponding to the concrete domain $C_p$.</p>
<p>Two functions for mapping to/from abstract/concrete domains are needed: (recall $v_{D_i}$)</p>
<ul>
<li>$Œ±: 2^S ‚Üí A$, from concrete domain to abstract domain. <em>abstraction function</em></li>
<li>$Œ≥: A ‚Üí 2^S$, from abstract domain to concrete domain. <em>concretization function</em></li>
</ul>
<p>Apparently, these functions should preserve partial order!</p>
<p>$F_p$ is operating on concrete domain $C_p$, so there should be a dual $\bar{F_p}$ on abstract domain $A_p$. It is valid if</p>
<p>$‚àÄ a ‚àà A . F_p(Œ≥(a)) ‚äÜ Œ≥(\bar{F_p}(a))$</p>
<p>Intuitively,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a    ‚Üí Fp-bar(a)</span><br><span class="line">‚ÜìŒ≥()             ‚Üò</span><br><span class="line">Œ≥(a) ‚Üí Fp(Œ≥(a)) ‚äÜ Œ≥(Fp-bar(a))</span><br></pre></td></tr></table></figure>

<p>which basically means $\bar{Fp}$ is a corresponding over-approximation of Fp in the abstract domain.</p>
<p>So, as you can see, all are operating on these two abstract/concrete domains.</p>
<p>‚ñ°</p>
<br/>

<p>PS: To display LaTeX symbols on this blog, I integrated MathJax engine, but it seems my blog engine Hexo will treat <code>_</code> as italic at a higher priority than subscript.. which lead to a lot of problems in re-formatting.. üòí</p>
</article><ul class="pager blog-pager"><li class="previous"><a href="/2016/09/30/%E4%BD%A0%E4%B8%80%E5%AE%9A%E7%88%B1%E8%AF%BB%E7%9A%84%E6%9E%81%E7%AE%80%E6%AC%A7%E6%B4%B2%E5%8F%B2/" data-toggle="tooltip" data-placement="top" title="‰Ω†‰∏ÄÂÆöÁà±ËØªÁöÑÊûÅÁÆÄÊ¨ßÊ¥≤Âè≤">‚Üê Previous Post</a></li><li class="next"><a href="/2016/09/09/Reading-Group-Learning-Syntactic-Program-Transformations-from-Examples/" data-toggle="tooltip" data-placement="top" title="Reading Group - Learning Syntactic Program Transformations from Examples">Next Post ‚Üí</a></li></ul><div class="disqus-comments"><div class="comments"><div id="disqus_thread"></div></div></div><script>var url_parts = window.location.href.split("?");
var disqus_url = url_parts[0];
(function () {
    console.log("enter disqus");
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = "//andriylin-blog.disqus.com/embed.js";
    (document.head || d.body ).appendChild(dsq);
})();</script></div></div></div><footer><div class="container beautiful-jekyll-footer"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href="/atom.xml" title="RSS"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-rss"></i></span></a></li><li><a href="mailto:xuankang.lin@gmail.com" title="Email me"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-envelope"></i></span></a></li><li><a target="_blank" rel="noopener" href="https://www.linkedin.com/in/xuankanglin/" title="LinkedIn"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-linkedin"></i></span></a></li><li><a target="_blank" rel="noopener" href="https://github.com/XuankangLin" title="GitHub"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-github"></i></span></a></li><li><a target="_blank" rel="noopener" href="https://weibo.com/andriylin/" title="Weibo"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-weibo"></i></span></a></li><li><a target="_blank" rel="noopener" href="https://www.douban.com/people/andriylin/" title="Douban"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-douban"></i></span></a></li><li><a target="_blank" rel="noopener" href="https://www.goodreads.com/xuankanglin" title="Goodreads"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-goodreads"></i></span></a></li></ul><p class="copyright text-muted">¬© gungunba ‚Ä¢ 2021
</p><p class="theme-by text-muted">Theme by
<a target="_blank" rel="noopener" href="https://github.com/twoyao/beautiful-hexo">beautiful-hexo</a></p></div></div></div></footer><script src="//cdn.bootcss.com/jquery/1.11.2/jquery.min.js"></script><script src="//cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/js/main.js"></script><script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script>(function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
    a = s.createElement(o),
            m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m)
})(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
ga('create', '[object Object]', 'auto');
ga('send', 'pageview');</script></body></html>