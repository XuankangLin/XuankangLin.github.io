<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><meta name="author" content="AndriyLin"><link rel="icon" href="/img/favicon.png"><title>Xuankang Lin</title><meta name="description" content="Personal Website of Xuankang Lin"><link rel="alternate" type="application/rss+xml" title="Xuankang Lin" href="/atom.xml"><link rel="stylesheet" href="//stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/css/highlight.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class="container-fluid"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target="#main-navbar" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">Xuankang's Blog</a></div><div id="main-navbar" class="collapse navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="/About-Me/">About</a></li><li><a href="/archives">Archive</a></li><li><a href="/tags">Tags</a></li></ul></div><div class="avatar-container"><div class="avatar-img-border"><a href="/"><img src="/img/avartar.jpg" class="avatar-img"></a></div></div></div></nav><header class="header-section"><div class="intro-header no-img"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><h1>Reading Group - Fencing off Go</h1><p class="post-meta">Posted on Feb 17, 2017 ¬∑ <a href="/tags/EN/" class="tag post-meta">EN</a></p></div></div></div></div></div></header><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role="main" class="blog-post"><p>Here is my note for paper <a href="http://dl.acm.org/citation.cfm?id=3009847" target="_blank" rel="noopener"><em>‚ÄúFencing off Go: Liveness and Safety for Channel-Based Programming‚Äù</em></a> when presenting it in our weekly paper reading group on 02/17/2017.</p>
<a id="more"></a>
<p>Please do not hesitate to correct me if I am wrong anywhere. Thanks in advance. üôÇ</p>
<p>BTW, I also found the <a href="https://www.doc.ic.ac.uk/~yoshida/slides/slides-ny.pdf" target="_blank" rel="noopener">slides</a> from author. Check it out.</p>
<p><br></p>
<p>02/23/2017 Update: Great thanks to Prof. <a href="http://www-kb.is.s.u-tokyo.ac.jp/~koba/" target="_blank" rel="noopener">Naoki Kobayashi</a> for generously sharing his thoughts and correcting some errors in this note!</p>
<p><br></p>
<h2 id="Why-picked-this-paper"><a href="#Why-picked-this-paper" class="headerlink" title="Why picked this paper"></a>Why picked this paper</h2><p>This paper is picked while iterating the papers list in POPL‚Äô17.</p>
<p>First of all, I need to admit that I‚Äôve not written programs in Go before. Actually I‚Äôd like to take this chance to know more about the concurrency model in Go language. One year ago I wrote about the <a href="/2016/02/03/Memory-Models-in-Go/">shared memory part of Go</a>. At that time I thought Go only has simple constructs in such concurrency consistency model, now I realize that I was seriously wrong, Go could be focusing more on the channel-based message-passing style concurrency.</p>
<p>Another minor reason for picking this paper is because of word ‚Äúfencing‚Äù. It‚Äôs only after reading the full paper that I realized ‚Äúfencing‚Äù is not talking about the ‚Äúfences/barriers‚Äù I am more familiar with.. I‚Äôve never used phrase ‚Äúfence off‚Äù (Êää‚Ä¶Áî®Ê†ÖÊ†èÈöîÂºÄ) before.. üòì</p>
<h2 id="Problem-amp-Contribution"><a href="#Problem-amp-Contribution" class="headerlink" title="Problem &amp; Contribution"></a>Problem &amp; Contribution</h2><p>According to the paper, for the channel-based message-passing style concurrency in Go language there is only runtime deadlock detector, but no compile time support on checking communication mismatch and partial deadlocks. The former is what they encode as ‚Äúliveness‚Äù property, and the latter is their ‚Äúchannel safety‚Äù property.</p>
<ul>
<li><p>Intuitively, the ‚Äúcommunication mismatch‚Äù means every read/write must be ‚Äúsynchronized‚Äù with some other write/read, i.e., a WRITE should be read and a READ should reads from some WRITE.</p>
</li>
<li><p>The channel-safety property is simpler ‚Äì channel is closed at most once, and closed channel cannot be used for output (writing to that channel), while input from closed is allowed, just returning default value.</p>
</li>
</ul>
<p>This is to conform with semantics in Go. Originally, I was thinking they provide some verification framework for general liveness and safety predicates. That‚Äôs not the case in this paper. Actually, I am wondering how difficult it would be to extend to general predicates. ü§î</p>
<p><br></p>
<p>In this paper, they complement this compile time support. Essentially, a behavioral type sytem defined and extracted from source code such that if Safety (or Liveness) property holds in the behavioral type layer, Safety (or Liveness) property holds (may hold) in source code layer.</p>
<p>For channel-safety property, type level safety ‚áí source code level safety. While this may not necessarily hold for liveness property. We will see that later on.</p>
<p>They claim to support ‚Äúdynamic channel creation‚Äù, ‚Äúunbounded thread creation‚Äù. I suspect that ‚Äúdynamic thread creation‚Äù is not supported at the moment, because I didn‚Äôt find corresponding semantics terms. But this may not be a big issue since analysis of Go source code could prepare this information beforehand.</p>
<h2 id="Example-‚Äì-Prime-Sieve"><a href="#Example-‚Äì-Prime-Sieve" class="headerlink" title="Example ‚Äì Prime Sieve"></a>Example ‚Äì Prime Sieve</h2><p>Before delving into details, let‚Äôs look at the Prime Sieve algorithm as an example demonstrating the entire workflow.</p>
<p>There is a very good visualization for Prime sieve algorithm in <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank" rel="noopener">wikipedia</a>. Basically, every prime number removes all future numbers that divdes this prime number.</p>
<p>In Go, the concurrent channel-based version could be written as:<br><img src="prime_sieve_in_go.png" alt><br>where</p>
<ul>
<li><code>Generate()</code> will be a Go Routine that keeps generating new numbers.</li>
<li><code>Filter()</code> will be a Go Routine transporting those numbers from input channel to output channel that is not dividable by a prime number.</li>
<li><code>main()</code> will be iterating all prime numbers, and use the filtered channel as new input channel.</li>
</ul>
<p>To reason about liveness and channel-safety properties of this algorithm, this paper will</p>
<ol>
<li>Infer a calculi from Go source code called <code>MiGo</code>, covering all channel-based concurrency usages.</li>
<li>Extract a behavioral type system for the calculi.</li>
<li>When it type checks, verify the liveness/safety properties at type level. The link between type-level and calculi level liveness/safety properties is proved in the paper.</li>
</ol>
<p>Regarding the prime sieve example, the extracted behavioral types would be:<br><img src="types_of_prime_sieve.png" alt><br>where</p>
<ul>
<li><code>t0</code> is the entry point of program.</li>
<li>$\bar{x}$ means writing to channel <code>x</code> while $x$ means reading from channel <code>x</code>.</li>
<li><code>g(x)</code> is for generator function, which writes something to channel <code>x</code> and recursively calls itself.</li>
<li><code>f(x,y)</code> is for filtering function, which first reads from channel <code>x</code> and then conditionally writes to channel <code>y</code> before recursively calling itself.</li>
<li><code>new b</code> means creating a new channel <code>b</code>.</li>
<li>$\oplus$ is branching / choice operator. <code>|</code> is for parallel composition.</li>
</ul>
<p>For this example, it can be shown that all 4 types are <em>fenced</em> (we will explain shortly). And they can be shown to hold the liveness and safety properties by unfolding the behavioral type semantics.</p>
<h2 id="Behavioral-Types"><a href="#Behavioral-Types" class="headerlink" title="Behavioral Types"></a>Behavioral Types</h2><p>Above is a quick view of extracted behavioral types. Frankly, I have not learned about this term before. According to survey <a href="http://www.behavioural-types.eu/publications/WG3SOAR.pdf" target="_blank" rel="noopener"><em>Behavioral Types in Programming Languages</em></a>:</p>
<blockquote>
<p>A recent trend in current research is to use behavioral type theory as the basis for new foundations, programming languages, and software development methods for communication-intensive distributed systems.</p>
</blockquote>
<blockquote>
<p>Behavioral type theory encompasses concepts such as interfaces, communication protocols, contracts, and choreography.</p>
</blockquote>
<blockquote>
<p>Roughly speaking, a behavioral type describes a software entity, such as an object, a communication channel, or a Web Service, in terms of the sequences of operations that allow for a correct interaction among the involved entities.</p>
</blockquote>
<p>And the authors seem to be experts in this area ‚Äì they appear in the authors list of this survey and one tutorial cited in the paper. BTW, session types seem to be one kind of behavioral types.</p>
<h2 id="Verification-of-Behavioral-Types"><a href="#Verification-of-Behavioral-Types" class="headerlink" title="Verification of Behavioral Types"></a>Verification of Behavioral Types</h2><p>As you can see, the defined behavioral type system is no longer simply carrying the type of payload data, it encodes certain behaviors in the type system. This makes it possible to define operational semantics on types.</p>
<p>Consequently, liveness / safety properties could be verified by the further defined operational semantics. In paper, this workflow is formulated as:</p>
<ul>
<li>If the symbolic executions of each Type holds the liveness / channel-safety property,</li>
<li>then the property holds at the Behavioral Type level,</li>
<li>then the property holds (maybe, in case of liveness) at the calculi level,</li>
<li>then the property holds at the source code (because calculi covers all channel-based concurrency).</li>
</ul>
<p>This 4 levels implication chain is my current comprehension of their entire approach workflow.</p>
<h2 id="Fenced"><a href="#Fenced" class="headerlink" title="Fenced"></a>Fenced</h2><p>However, with the straightforwardly defined behavioral types, it may not be decidable (proved long long ago). Thus a subset of types needs to be identified which could make it decidable. That is their <em>fenced types</em>.</p>
<p>// <em>02/23/2017: Thanks Prof. Naoki for sharing his thoughts and correcting some errors here!</em></p>
<p><em>Below is my Revised Understanding:</em></p>
<p>The semantics of their Types is defined in Fig. 5 using ‚Äútypes as Calculus of Computing Systems (CCS) processes‚Äù interpretation. The resulting Labeled Transition System (LTS) provides a state space to explore, which is possibly infinite and thus undecidable.</p>
<p>To resolve this, they define in Fig. 7 a Symbolic Semantics for Types, which can explore only a finite subset of the possibly infinite state space which could therefore make it decidable. This finiteness guarantee is made possible by additional parameters <code>k</code> and <code>N</code>, where <code>k</code> is the bound on steps (e.g. k-liveness / k-safety) and <code>N</code> is the bound on used channel names.</p>
<ul>
<li><p>Regarding <code>k</code>: When <code>k</code> is infinity,  ‚àû-liveness/safety will again need to explore the possibly infinite state space. So ‚àû-liveness/safety is undecidable.</p>
</li>
<li><p>Regarding <code>N</code>: This bound is ensured by ‚ÄúFenced‚Äù. My current intuition about their ‚ÄúFenced‚Äù definition is elaborated as below:</p>
<p>  In semantics rules, they require in Def. 4.1 that:</p>
<blockquote>
<p>types featuring parallel composition have a ‚Äúfinite memory‚Äù w.r.t. the names over which they can recurse.</p>
</blockquote>
<p>  For types without parallel composition, there is no restriction because this whole thing is regulating concurrent behaviors.</p>
<p>  With parallel composition, they require channel names used in recursion to be ‚Äúfinitely many‚Äù, i.e., it‚Äôs fine to create new channels during recursion, as long as some same-amount old channel names are removed from scope and garbage collected. Therefore, the overall ‚Äúspots‚Äù remains unchanged, and may ‚Äúreduce to same state in LTS‚Äù. Through Œ±-equivalence and structural congruence (see Proof for Lemma 4.1 in <a href="https://arxiv.org/abs/1610.08843" target="_blank" rel="noopener">extended version paper</a>), even if there are infinitely many channel names being created, they can reduce to finitely many states (with <code>k</code>-bounded).</p>
</li>
</ul>
<p><br></p>
<p>Let‚Äôs look in some visualized examples in addition to textual explainations. Intuitively, ‚Äúhaving finite memory of channel names during recursion‚Äù implies no channel names should appear infinitely often. In other words, they appear in some <em>fenced</em> region. This is why they call it ‚Äúfenced types‚Äù.</p>
<p>Below is one true fenced type diagram:<br><img src="fenced_type_correct.png" alt><br>The blue region is where channel <code>a</code> appears. The red region is where channel <code>b1</code> appears. In the following wrong fenced type diagram:<br><img src="fenced_type_wrong.png" alt><br>channel <code>a</code> appears infinitely often, it‚Äôs not fenced.</p>
<h2 id="Special-Cases-Regarding-Liveness"><a href="#Special-Cases-Regarding-Liveness" class="headerlink" title="Special Cases Regarding Liveness"></a>Special Cases Regarding Liveness</h2><p>We mentioned earlier that channel-safety property can flow from behavioral type level to calculi level while this is not necessarily the case for liveness property.</p>
<p>This is because Type System is actually an approximation of code / calculi.</p>
<blockquote>
<p>For the case of liveness, programs typically rely on data values to guide their control flow (e.g. in conditional branches) which are abstracted away at the type level.</p>
</blockquote>
<p>For example, the liveness property may depend on exactly one branch in <code>if</code> conditional statement. If the <code>if</code> condition is always true or always false, the liveness property may not hold.</p>
<p>In the paper, they identify 3 special cases where liveness at the behavioral type level can extend to liveness at the calculi level:</p>
<ol>
<li>May Terminate</li>
<li>Without infinitely running conditionals</li>
<li>Non-deterministic conditional</li>
</ol>
<p>I am not going into details of these here.</p>
<h2 id="My-Thoughts"><a href="#My-Thoughts" class="headerlink" title="My Thoughts"></a>My Thoughts</h2><p>Apparently, the key step in this paper is to successfully apply behavioral types.</p>
<p>I don‚Äôt know much about those type systems, and may not be doing type-system related works in foreseeable future. But in my shallow understanding, the verification effort still exists there, but now transfers from source code level to behavioral type level.</p>
<p>Hence, my doubt is how much would it gain to do such symbolic execution analysis at the type level? Maybe it becomes more powerful with additional type information? The authors do mention doing model checking with the defined operational semantics. Why is it better to do such thing in type level remains to be my overall question.</p>
<p>If the type system continues to approximate more and more of code, could we eventually apply concurrency logics (e.g. Rely/Guarantee) in the very rich type system? I‚Äôd be very interested if that is possible.</p>
<p>Besides, as mentioned earlier in the note, I am also wondering how difficult it would be to extend the current livenss / channel-safety properties to general predicates?</p>
<p>ü§î</p>
</article><ul class="pager blog-pager"><li class="previous"><a href="/2017/03/24/ËµÑÊ≤ªÈÄöÈâ¥‚Äî‚ÄîÊàòÂõΩ„ÄÅÁß¶/" data-toggle="tooltip" data-placement="top" title="ËµÑÊ≤ªÈÄöÈâ¥‚Äî‚ÄîÊàòÂõΩ„ÄÅÁß¶">‚Üê Previous Post</a></li><li class="next"><a href="/2017/02/14/Ëá™ÂÆö‰πâ-RSS-Feed-ËØïÈ™åËÆ∞ÂΩï/" data-toggle="tooltip" data-placement="top" title="Ëá™ÂÆö‰πâ RSS Feed ËØïÈ™åËÆ∞ÂΩï">Next Post ‚Üí</a></li></ul><div class="disqus-comments"><div class="comments"><div id="disqus_thread"></div></div></div><script>var url_parts = window.location.href.split("?");
var disqus_url = url_parts[0];
(function () {
    console.log("enter disqus");
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = "//andriylin-blog.disqus.com/embed.js";
    (document.head || d.body ).appendChild(dsq);
})();</script></div></div></div><footer><div class="container beautiful-jekyll-footer"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href="https://weibo.com/andriylin/" title="Weibo"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-weibo"></i></span></a></li><li><a href="https://twitter.com/AndriyLin" title="Twitter"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-twitter"></i></span></a></li><li><a href="https://www.instagram.com/verified_andriy/" title="Instagram"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-instagram"></i></span></a></li><li><a href="https://www.douban.com/people/andriylin/" title="Douban"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-douban"></i></span></a></li><li><a href="https://www.goodreads.com/xuankanglin" title="Goodreads"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-goodreads"></i></span></a></li><li><a href="https://github.com/AndriyLin" title="GitHub"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-github"></i></span></a></li><li><a href="mailto:xuankang.lin@gmail.com" title="Email me"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-envelope"></i></span></a></li><li><a href="/atom.xml" title="RSS"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-rss"></i></span></a></li></ul><p class="copyright text-muted">¬© AndriyLin ‚Ä¢ 2020
</p><p class="theme-by text-muted">Theme by
<a href="https://github.com/twoyao/beautiful-hexo">beautiful-hexo</a></p></div></div></div></footer><script src="//cdn.bootcss.com/jquery/1.11.2/jquery.min.js"></script><script src="//cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/js/main.js"></script><script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script>(function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
    a = s.createElement(o),
            m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m)
})(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
ga('create', '[object Object]', 'auto');
ga('send', 'pageview');</script></body></html>